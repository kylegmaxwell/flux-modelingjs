/** @file Helper functions and classes to generate valid JSON queries to Geometry Worker server.
 *  Use {@link scene} as a starting point
 *  @author Igor Baidiuk <ibaidiuk@amcbridge.com>
 */

/* jslint node:true */

(function (define) { /* 'use strict';*/ define(function(require) {
// TODO Use strict should be enabled. Previously the statement was there,
// but had no effect because it was at the top of the file. See PLT-3108.

var uuid = require('./uuid');

var eps = 1e-8;

// Object that containts 'genId' method, to be used for GUID generation
// Needed for test purposes
var gen_id_object = undefined;

/* Generate uuid, that will be used as geometry id
 */
function guid() {
    if (isNone(gen_id_object) || isNone(gen_id_object.genId)) {
        return uuid.v4();
    }
    return gen_id_object.genId();
}
// Get id from entity
function getId(e) {
    if (e.id) {
        return e.id;
    } else if (e.__data__) {
        return e.__data__.id;
    }
    return null;
}
/* Converts any array-like object to actual array
   Used mostly with Arguments objects
 */

var DEFAULT_LINEAR_TOLERANCE = 0.1;
var DEFAULT_ANGULAR_SIZE     = 30.0;

function toArray(obj) {
    return Array.prototype.slice.call(obj);
}

function notImplemented() {
    throw Error('not implemented');
}

function normalize(arr) {
    var m = Math.sqrt(arr[0]*arr[0] + arr[1]*arr[1]  + arr[2]*arr[2]);
    return [arr[0]/m, arr[1]/m, arr[2]/m];
}

function xor(l, r) { return l ? !r : r; }
// Common dump function, returns text representation
// check for both null and undefined
function isNone(value) { return value === null || value === undefined; }

function isInst(value, type) {
    if (!(type instanceof Function))
        throw Error('type: constructor expected');
    if (isNone(value))
        return false;
    return (value instanceof type) || value.constructor == type;
}
// Inherit one type from another, adding methods via prototype object
function inherit(clazz, base, proto) {
    clazz.prototype = Object.create(base.prototype);
    clazz.prototype.constructor = clazz;
    if (proto)
        Object.keys(proto).forEach(
            function (key) {
                clazz.prototype[key] = proto[key];
            }
        );
}

//******************************************************************************
// Type declarations
//******************************************************************************
/** Use factory function {@link scene}
 *  @class
 *  @classdesc Represents block query as scene, with geometrical entities and operations over there
 */
function Scene() {
    this.__entities__   = {};
    this.__operations__ = [];
    this.__counter__    = 1;
}
/** Creates new scene object
 *
 *  @return {Scene} new empty scene object
 */
var scene = function () { return new Scene(); };
/** Converts Scene object to JSON representation
 *  Adds custom-conversion support for {@link JSON.stringify}
 *
 *  @return {*} JSON-ready object
 */
Scene.prototype.toJSON  = function () {
    var ops = dumpOperations(this);
    return {
        Entities:   dumpEntities(this),
        Operations: ops
    };
};
/* Resolves Entity or Operation object into its name in query
   Entities without a name are assigned with autogenerated name
   Operations without a name return no name and thus expanded in-place

   @param  {Entity|Operation} object - to be resolved
   @param  {number}           index  - index of current operation block, used to block forward lookups
   @return {string}                    item name, if any
 */
function resolveItem(self, e, opIndex) {
    var key;
    if (e instanceof Entity) {
        Object.keys(self.__entities__).forEach(function (k) {
            if (!key && self.__entities__[k] === e) {
                key = k;
            }
        });
        if (!key) {
            key = e.primitive + '@' + self.__counter__;
            self.__entities__[key] = e;
            self.__counter__ += 1;
        }
        return key;
    }
    else if (e instanceof Operation) {
        var ops = self.__operations__;
        var i;

        // find latest binding
        for (i = opIndex - 1; i >= 0; i -= 1) {
            var item = ops[i];
            if (item.operation === e) {
                key = item.name;
                break;
            }
        }
        // check if binding wasn't overridden later
        if (key)
            for (var j = opIndex - 1; j > i; j -= 1)
                if (ops[j].name === key)
                    return undefined;

        return key;
    }
}

function dumpOperations(self) {
    var r = [];
    function makeResolver (i) {
        return function(e) { return resolveItem(self, e, i); };
    }

    for (var i = 0, e = self.__operations__.length; i < e; ++i)
        try {
            var item = self.__operations__[i];
            item.__resolver__ = makeResolver(i);
            r.push(item.toJSON());
        }
        finally {
            i.__resolver__ = undefined;
        }
    return r;
}

/*  @class
    @classdesc Named operation slot
 */
function OpSlot(name, op) {
    this.name = name;
    this.operation = op;
}
OpSlot.prototype.toJSON = function () {
    var op = null;
    try {
        this.operation.__resolver__ = this.__resolver__;
        op = this.operation.toJSON();
    }
    finally {
        this.operation.__resolver__ = undefined;
    }
    return {
        name: this.name,
        op:   op
    };
};

/** Adds entity/operation to scene
 *
 *  @param  {string}             name - name of item being added
 *  @param  {Entity|Operation}   obj  - either entity or operation being added
 *  @return {this}                      this, for chaining
 */
Scene.prototype.add = function(name, obj) {
    if (!isInst(name, String))
        throw Error('name: string expected');
    if (isInst(obj, Entity)) {
        if (this.__entities__[name] !== undefined)
            throw Error('entity "' + name + '" already defined');
        this.__entities__[name] = obj;
    }
    else if (obj.primitive !== undefined) {
        this.__entities__[name] = entities.raw(obj);
    }
    else if (isInst(obj, Operation)) {
        this.__operations__.push(new OpSlot(name, obj));
    }
    else
        throw Error('obj: either Entity or Operation is expected');
    return this;
};

//******************************************************************************
/** Use factory function {@link dcmScene}
 *  @class
 *  @classdesc Represents block query as scene, with geometrical entities, constraints, variables, equations and operations over there
 */
function DCMScene() {
    this.__entities__   = {};
    this.__constraints__ = {};
    this.__variables__ = {};
    this.__equations__ = {};
    this.__operations__ = [];
}

// Adds array of elements to scene
DCMScene.prototype.addMultiple = function (elements) {
    var self = this;
    Object.keys(elements).forEach(function(key){
        self.add(elements[key], key);
    });
};

/** Creates new scene object
 *  @param  {Object} value - optional, object with entities, constraints, etc.., to initialize scene
 *
 *  @return {DCMScene} new scene object
 */
var dcmScene = function (value) {
    var scene = new DCMScene();
    if (value) {
        Object.keys(value).forEach(function(key) {
            if (value[key])
                scene.addMultiple(value[key]);
        });
    }

    return scene;
};
/** Converts DCMScene object to JSON representation
 *  Adds custom-conversion support for {@link JSON.stringify}
 *
 *  @return {*} JSON-ready object
 */
DCMScene.prototype.toJSON  = function () {
    var ops = dumpDCMOperations(this);
    var equats = dumpEquations(this);
    var vars = dumpVariables(this);
    var cons = dumpConstraints(this);
    return {
        Entities:       dumpEntities(this),
        Constraints:    cons,
        Variables:      vars,
        Equations:      equats,
        Operations:     ops
    };
};

/* Resolves Entity, Constraint, Variable, Equation or Operation object into its name in query
   Entities, Constraints, Variables and Equations without a name are assigned with guid
   Operations without a name return no name and thus expanded in-place

   @param  {Entity|Constraint|Variable|Equation|Operation}  object to be resolved
   @param  {number}                                         index of current operation block, used to block forward lookups
   @return {string}                                         item name, if any
 */
function resolveDCMItem(self, e, opIndex) {
    var key;
    if (e instanceof Entity) {
        Object.keys(self.__entities__).forEach(function (k) {
            if (!key && self.__entities__[k] === e) {
                key = k;
            }
        });
        if (!key) {
            key = getId(e) || guid();
            self.__entities__[key] = e;
        }
    }
    else if (e instanceof Operation) {
        var ops = self.__operations__;
        var i;

        // find latest binding
        for (i = opIndex - 1; i >= 0; i -= 1) {
            var item = ops[i];
            if (item.operation === e) {
                key = item.name;
                break;
            }
        }
        // check if binding wasn't overridden later
        if (key)
            for (var j = opIndex - 1; j > i; j -= 1)
                if (ops[j].name === key)
                    return undefined;
    }
    return key;
}

/*  Internal function, converts given objects to JSON
 */
function dumpElements(self, elements) {
    var r = {};
    var es = elements;
    Object.keys(elements).forEach(
        function (k) {
            r[k] = es[k].toJSON();
        }
    );

    return r;
}

/*  Internal function, converts entity objects to JSON
 */
function dumpEntities(self) {
    return dumpElements(self, self.__entities__);
}

/*  Internal function, converts constraint objects to JSON
 */
function dumpConstraints(self) {
    return dumpElements(self, self.__constraints__);
}

/*  Internal function, converts variable objects to JSON
 */
function dumpVariables(self) {
    return dumpElements(self, self.__variables__);
}

/*  Internal function, converts variable objects to JSON
 */
function dumpEquations(self) {
    return dumpElements(self, self.__equations__);
}

function dumpDCMOperations(self) {
    var r = [];
    function makeResolver (i) {
        return function(e) { return resolveDCMItem(self, e, i); };
    }

    for (var i = 0, e = self.__operations__.length; i < e; ++i)
        try {
            var item = self.__operations__[i];
            item.__resolver__ = makeResolver(i);
            r.push(item.toJSON());
        }
        finally {
            i.__resolver__ = undefined;
        }
    return r;
}

DCMScene.prototype.hasEntity = function (name) {
    return this.__entities__[name] !== undefined;
};

DCMScene.prototype.hasConstraint = function (name) {
    return this.__constraints__[name] !== undefined;
};

DCMScene.prototype.hasVariable = function (name) {
    return this.__variables__[name] !== undefined;
};

DCMScene.prototype.hasEquation = function (name) {
    return this.__equations__[name] !== undefined;
};

// Helper function. Switches all ids in entity fields to new guids
function updateEntityIds (elem) {
    if (elem && elem.__data__) {
        var data = elem.__data__;
        var idFields = ['startId', 'endId', 'originId'];
        idFields.forEach(function(field){
            if (data.hasOwnProperty(field)) {
                data[field] = guid();
            }
        });

        // 'id' field is obligatory
        data.id = guid();
    }

    return elem;
}

DCMScene.prototype.updateEntity = function (old) {
    var name = getId(old);
    var self = this;
    if (!self.hasEntity(name))
        throw Error("Entity " + name + " is not present in scene");
    var e = self.__entities__[name];
    updateEntityIds(e);
    return e;
};

// Generates entities related to given one (e.g. end points
// of the line), adds them and entity itself to scene
DCMScene.prototype.addEntity = function(entity, name) {
    var self = this;
    var data = entity.__data__;
    switch (data.primitive)
    {
        case 'point':
        case 'curve':
        {
            // Entity is self-sufficient, so need to add only entity itself
            break;
        }
        case 'line':
        {
            if (!self.hasEntity(data.startId)) {
                self.addEntity(entities.point(data.start, data.startId), data.startId);
            }
            if (!self.hasEntity(data.endId)) {
                self.addEntity(entities.point(data.end, data.endId), data.endId);
            }
            break;
        }
        case 'circle':
        case 'ellipse':
        {
            if (!self.hasEntity(data.originId)) {
                self.addEntity(entities.point(data.origin, data.originId), data.originId);
            }
            break;
        }
        case 'arc':
        {
            if (!self.hasEntity(data.originId)) {
                var origin = getCircleCenterByThreePoints(data.start, data.middle, data.end);
                self.addEntity(entities.point(origin, data.originId), data.originId);
            }
            if (!self.hasEntity(data.startId)) {
                self.addEntity(entities.point(data.start, data.startId), data.startId);
            }
            if (!self.hasEntity(data.endId)) {
                self.addEntity(entities.point(data.end, data.endId), data.endId);
            }
            break;
        }
        case 'polyline':
        {
            notImplemented(); // TODO Need to know which blocks will be given as inputs
            break;
        }
        case 'polycurve':
        {
            notImplemented(); // TODO Implement after polyline
            break;
        }
        default:
        {
            throw Error("Entity with primitive " + entity.primitive + " can not be added to scene");
        }
    }

    self.__entities__[name] = entity;
};
/** Adds entity/constraint/variable/equation/operation to scene
 *
 *  @param          obj  - either entity, constraint, variable, equation or operation being added
 *  @param {string} name - name of item being added
 *  @return              - this object, for chain of calls
 */
DCMScene.prototype.add = function(obj, name) {
    name = name || getId(obj);
    if (!isInst(name, String))
        throw Error('name: string expected ' + name + '   ' + JSON.stringify(obj));
    if (isInst(obj, Entity)) {
        if (!this.hasEntity(name))
            this.addEntity(obj, name);
    }
    else if (isInst(obj, Constraint)) {
        if (this.hasConstraint(name))
            throw Error('constraint "' + name + '" already defined');
        this.__constraints__[name] = obj;
    }
    else if (isInst(obj, Variable)) {
        if (this.hasVariable(name))
            throw Error('variable "' + name + '" already defined');
        this.__variables__[name] = obj;
    }
    else if (isInst(obj, Equation)) {
        if (this.hasEquation(name))
            throw Error('equation "' + name + '" already defined');
        this.__equations__[name] = obj;
    }
    else if (obj.primitive !== undefined) {
        if (!this.hasEntity(name))
            this.addEntity(entities.raw(obj), name);
    }
    else if (obj.type !== undefined) {
        if (this.hasConstraint(name))
            throw Error('constraint "' + name + '" already defined');
        this.__constraints__[name] = constraints.raw(obj);
    }
    else if (obj.name !== undefined && obj.value !== undefined) {
        throw Error('Adding raw variable is not supported');
    }
    else if (obj.equation !== undefined) {
        throw Error('Adding raw equation is not supported');
    }
    else if (isInst(obj, Operation)) {
        this.__operations__.push(new OpSlot(name, obj));
    }
    else
        throw Error('obj: either Entity, Constraint, Variable, Equation or Operation is expected');
    return this;
};

//******************************************************************************
/** Use functions from {@link entities} to construct
 *  @class
 *  @classdesc Represents entity in Flux protocol. These objects are added to the 'Entities' part of scene
 */
function Entity(id) { this.primitive = id; }
/** JSON representation of entity
 *  Adds support for {@link JSON.stringify}
 *
 *  @return {*} JSON object
 */
Entity.prototype.toJSON    = function() { return this.__data__; };

/** Add attribute to entity
 *  If first argument is a string, it's treated as attribute type,
 *  and second argument is treated as attribute value.
 *  Otherwise, first argument is treated as full attribute object.
 *  Its type key is retrieved via type() method,
 *  and the whole object is used as attribute value.
 *  See {@link attributes} for known attribute types
 *
 *  @param  {*|string} objkey  - either attribute key (string) or full attribute object (*)
 *  @param  {*}        [value] - raw attribute value
 *  @return {this}               this, for chaining
 */
Entity.prototype.attribute = function(keyobj, value) {
    var d = this.__data__;
    var key;
    if (typeof(keyobj) === "string")
        key = keyobj;
    else
    {
        key = keyobj.type();
        value = keyobj;
    }

    if (!d.attributes)
        d.attributes = {};
    if (d.attributes[key])
        throw Error("attribute of type '" + key + "' already defined");
    d.attributes[key] = value;
    return this;
};
//******************************************************************************/
// Pseudo-classes representing entity categories

/**
 *  @class
 *  @extends Entity
 *  @classdesc Represents any limited embodied geometry
 */
function Body() { Entity.apply(this, arguments); }
// Inherit Body from Entity
inherit(Body, Entity,
/** @lends Body.prototype */
{
    /** Adds axis vector to the body
    *   @param {number[]|Vector} a - axis vector
    *   @return {this}               this, for chaining
    */
    axis: function (a) {
        this.__data__.axis = vecCoords(a);
        return this;
    },
    /** Adds reference vector to the body
    *   @param {number[]|Vector} ref - reference vector
    *   @return {this}                 this, for chaining
    */
    reference: function (ref) {
        this.__data__.reference = vecCoords(ref);
        return this;
    }
});
/**
 *  @class
 *  @extends Body
 *  @classdesc Represents 3D point
 */
function Point() { Body.apply(this, arguments); }
inherit(Point, Body);
/**
 *  @class
 *  @extends Body
 *  @classdesc Wire entities, i.e. polylines, curves, ellipses
 */
function Wire() { Body.apply(this, arguments); }
inherit(Wire, Body);
/**
 *  @class
 *  @extends Body
 *  @classdesc Sheet entities, i.e. polygon sets, surfaces
 */
function Sheet() { Body.apply(this, arguments); }
inherit(Sheet, Body);
/**
 *  @class
 *  @extends Body
 *  @classdesc Solid entities, i.e. meshes, spheres, boxes
 */
function Solid() { Body.apply(this, arguments); }
inherit(Solid, Body);
/**
 *  @class
 *  @extends Body
 *  @classdesc General bodies; can be received only as a result of some operation
 */
function General() { Body.apply(this, arguments); }
inherit(General, Body);

/**
 *  @class
 *  @extends Entity
 *  @classdesc Analytical geometry entities
 */
function Geometry() { Entity.apply(this, arguments); }
inherit(Geometry, Entity);
/**
 *  @class
 *  @extends Geometry
 *  @classdesc Infinite plane
 */
function Plane() { Geometry.apply(this, arguments); }
inherit(Plane, Geometry);
/**
 *  @class
 *  @extends Geometry
 *  @classdesc 3D direction vector
 */
function Vector() { Geometry.apply(this, arguments); }
inherit(Vector, Geometry);

/** Helper function

    @private
    @param  {string}   typeid  - name of entity type, value for 'primitive' property
    @param  {any}      params  - additional parameters of entity
    @param  {function} OptCtor - optional, constructor function; {@link Entity} if undefined
    @return {Entity}             Entity or any other type specified by OptCtor
*/
function primitive(typeid, params, OptCtor) {
    OptCtor = OptCtor || Entity;
    var e = new OptCtor(typeid);
    e.__data__ = params;
    e.__data__.primitive = typeid;
    return e;
}
// if arg is array, returns it; if it's a point, returns its coords as array
function coords(obj) {
    if (Array.isArray(obj))
        return obj;
    if (obj instanceof Point)
        return coords(obj.toJSON().point);
    if (obj.primitive == "point")
        return coords(obj.point);
    throw Error("expected array of numbers or Point entity");
}

function mapCoords(vec) {
    var out = [];
    for (var i = 0, e = vec.length; i < e; ++i)
        out.push(coords(vec[i]));
    return out;
}

function vecCoords(obj) {
    if (Array.isArray(obj))
        return obj;
    if (obj instanceof Vector)
        return vecCoords(obj.toJSON().coords);
    if (obj.primitive == "vector")
        return coords(obj.coords);
    throw Error("expected array of numbers or Vector entity");
}

function mapVecCoords(vec) {
    var out = [];
    for (var i = 0, e = vec.length; i < e; ++i)
        out.push(vecCoords(vec[i]));
    return out;
}

// Multiply 2 matrices
function multMatrix(a, b) {
    var len = a.length;

    var c = new Array(len);
    var i;

    var dim = Math.sqrt(len);

    for (i = 0; i < dim; ++i)
        for (var j = 0; j < dim; ++j) {
            var s = 0;
            for (var k = 0 ; k < dim; ++k)
                s += a[i * dim + k] * b[k * dim + j];
            c[i * dim + j] = s;
        }
    return c;
}
// Applies additional affine transform by pre-multiplying
function applyMatrix(self, m) {
    self.__data__.mat = multMatrix(m, self.__data__.mat);
    return self;
}

/** Use {@link entities.affine} to construct
 *  @class
 *  @extends Entity
 *  @classdesc Entity which represents affine transformation matrix
 */
function Affine() { Entity.apply(this, arguments); }
// Inherit Affine from Entity
inherit(Affine, Entity,
/** @lends Affine.prototype */
{
    /** Adds 3D translation
     *  @param  {number[]|Vector} delta - translation vector
     *  @return {this}                    this, for chaining
     */
    translate: function (d) {
        d = vecCoords(d);
        return applyMatrix(this, [
             1,  0,  0, d[0],
             0,  1,  0, d[1],
             0,  0,  1, d[2],
             0,  0,  0,  1
        ]);
    },
    /** Adds 3D rotation around X axis
     *  @param  {number} phi - rotation angle, in degrees
     *  @return {this}         this, for chaining
     */
    rotateX: function (phi) {
        phi = phi * Math.PI / 180;
        var sin = Math.sin(phi), cos = Math.cos(phi);
        return applyMatrix(this, [
             1,    0,    0, 0,
             0,  cos,  sin, 0,
             0, -sin,  cos, 0,
             0,    0,    0, 1
        ]);
    },
    /** Adds 3D rotation around Y axis
     *  @param  {number} phi - rotation angle, in degrees
     *  @return {this}         this, for chaining
     */
    rotateY: function (phi) {
        phi = phi * Math.PI / 180;
        var sin = Math.sin(phi), cos = Math.cos(phi);
        return applyMatrix(this, [
              cos, 0, -sin, 0,
                0, 1,    0, 0,
              sin, 0,  cos, 0,
                0, 0,    0, 1
        ]);
    },
    /** Adds 3D rotation around Z axis
     *  @param  {number} phi - rotation angle, in degrees
     *  @return {this}         this, for chaining
     */
    rotateZ: function (phi) {
        phi = phi * Math.PI / 180;
        var sin = Math.sin(phi), cos = Math.cos(phi);
        return applyMatrix(this, [
              cos,  sin, 0, 0,
             -sin,  cos, 0, 0,
                0,    0, 1, 0,
                0,    0, 0, 1
        ]);
    },
    /** Adds 3D scaling
     *  @param  {number[]|Vector} scale - scaling vector
     *  @return {this}                    this, for chaining
     */
    scale: function(s) {
        s = vecCoords(s);
        return applyMatrix(this, [
             s[0],  0,   0,  0,
               0, s[1],  0,  0,
               0,   0, s[2], 0,
               0,   0,   0,  1
        ]);
    },
    /** Rotate around arbitrary vector
     *  @param  {number[]|Vector} axis - rotation axis
     *  @param  {number}          phi  - rotation angle, in degrees
     *  @return {this}                   this, for chaining
     */
    rotateAboutAxis: function (a, phi) {
        phi = phi * Math.PI / 180;
        var sin = Math.sin(phi), cos = Math.cos(phi);
        a = vecCoords(a);
        a = normalize(a);
        var x = a[0], y = a[1], z = a[2];
        return applyMatrix(this, [
            cos+x*x*(1-cos),    x*y*(1-cos)-z*sin, y*sin+x*z*(1-cos),  0,
            z*sin+x*y*(1-cos),  cos+y*y*(1-cos),   -x*sin+y*z*(1-cos), 0,
            -y*sin+x*z*(1-cos), x*sin+y*z*(1-cos), cos+z*z*(1-cos),    0,
            0,                  0,                 0,                  1
        ]);
    },
    /** Reflect against specified plane
     *  @param  {number[]|Point} normal - plane's normal vector
     *  @param  {number[]|Point} origin - in-plane point
     *  @return {this}        this, for chaining
     */
    reflection: function (n, p) {
        n = vecCoords(n);
        p = coords(p);
        var nx = n[0], ny = n[1], nz = n[2],
            px = p[0], py = p[1], pz = p[2];

        var len = Math.sqrt(nx*nx + ny*ny + nz*nz);
        nx /= len; ny /= len; nz /= len;

        var d = -nx * px - ny * py - nz * pz;

        return applyMatrix(this, [
            1.0 - 2 * nx * nx,  -2 * nx * ny,       -2 * nx * nz,       -2 * nx * d,
            -2 * nx * ny,       1.0 - 2 * ny * ny,  -2 * ny * nz,       -2 * ny * d,
            -2 * nx * nz,       -2 * ny * nz,       1.0 - 2 * nz * nz,  -2 * nz * d,
            0,                  0,                  0,                  1
        ]);
    },

    /** Compose with another transformation
     *  @param {affine} t - transformation to compose with.
     */
     compose: function (t) {
        return applyMatrix(this, t.mat || t.__data__.mat);
     }
});

/** Use {@link entities.polygonSet} to construct
 *  @class
 *  @extends Sheet
 *  @classdesc Entity which represents set of polygons
 */
function PolygonSet() { Sheet.apply(this, arguments); }
// inherit PolygonSet from Entity
inherit(PolygonSet, Sheet,
/** @lends PolygonSet.prototype */
{
    /** Adds new outer boundary loop polygon to set
     *
     *  @function
     *  @param  {...(number[]|Point)} points - a set of points representing polygon
     *  @return {this}                 this, for chaining
     */
    boundary: function () { // add polygon to set
        var polys = this.__data__.polygons;

        polys.push({
            boundary: mapCoords(arguments),
            holes: []
        });
        return this;
    },
    /** Adds inner hole loop to the last polygon in a set
     *
     *  @function
     *  @param  {...(number[]|Point)} points - a set of points representing hole
     *  @return {this}                 this, for chaining
     */
    hole: function() { // add hole to last polygon
        var polys = this.__data__.polygons;
        var last = polys[polys.length - 1];
        last.holes.push(mapCoords(arguments));
        return this;
    }
});
/** Use {@link entities.mesh} to construct
 *  @class
 *  @extends Solid
 *  @classdesc Entity which represents 3D polygonal mesh
 */
function Mesh() { Solid.apply(this, arguments); }
// inherit Mesh from Entity
inherit(Mesh, Solid,
/** @lends Mesh.prototype */
{
    /** Adds vertex to mesh
     *
     *  @function
     *  @param  {number[]|Point} coords
     *  @return {this}           this, for chaining
     */
    vertex: function (c) {
        this.__data__.vertices.push(coords(c));
        return this;
    },
    /** Builds new face in mesh from vertex indices
     *
     *  @function
     *  @param  {...number} index - indices of vertices constituting face
     *  @return {this}              this, for chaining
     */
    face: function() {
        this.__data__.faces.push(toArray(arguments));
        return this;
    }
});

function appendToField(field) {
    return function() {
        var self = this;
        toArray(arguments).forEach(function (i) {
            self.__data__[field].push(i);
        });
        return this;
    };
}
// Transforms incoming data item to 'canonical' weighted vertex form
// Canonical form is a 2-element array, with first element being 3-element array with point coordinates
// and second being either weight noumber or 'undefined'
//
// Supported forms are:
// 1. 3-number array  - unweighted
// 2. 4-number array  - weighted
// 3. Point           - unweighted
// 4. [Point]         - unweighted
// 5. [Point, number] - weighted
// 6. Point.toJSON()  - unweighted
function canonicVertex(item) {
    if (Array.isArray(item)) {       // one of array cases
        if (item.length == 1)
            // repr #4 - unpack single array element and try to treat it as item
            return canonicVertex(item[0]);
        if (item.length == 2)
            // repr #5
            return [coords(item[0]), item[1]];
        if (item.length == 3)
            // repr #1
            return [item, undefined];
        if (item.length == 4)
            // repr #2
            return [item.slice(0, 3), item[3]];
    }
    else if (item instanceof Point || item.primitive == "point") // Point case
        // repr #3, #6
        return [coords(item), undefined];
    // Didn't match anything, so just throw
    throw Error("Unsupported vertex representation");
}

function appendVertex(ctxt, item) {
    item = canonicVertex(item);
    var pt = item[0], w = item[1];

    if (ctxt.weights === undefined) {
        if (w !== undefined) {
            if (ctxt.points.length === 0)
                ctxt.weights = [ w ];
            else
                throw Error('Cannot add weighted vertex because previous vertices were weightless');
        }
        ctxt.points.push(pt);
    }
    else {
        if (w === undefined)
            throw Error('Vertex must have weight specified');
        ctxt.weights.push(w);
        ctxt.points.push(pt);
    }
    // NB: case where points are empty, and weights are not, isn't an error - because weights are in a linear array, and points aren't always
}

/** Use {@link entities.curve} to construct
 *  @class
 *  @extends Wire
 *  @classdesc Entity which represents NURBS curve
 */
function Curve() { Wire.apply(this, arguments); }
// inherit Curve from Wire
inherit(Curve, Wire,
/** @lends Curve.prototype */
{
    /** Appends numbers to array of knots
     *
     *  @function
     *  @param  {...number} knot - knot values
     *  @return {this}             this, for chaining
     */
    knots:  appendToField('knots'),
    /** Adds curve vertex, either weighted or weightless
     *
     *  Weightless vertices are specified in one of the following formats:
     *  - 3 numbers
     *  - 1 Point
     *  - array of 3 numbers
     *  Weighted vertices are specified in one of the following formats:
     *  - 4 numbers
     *  - 1 Point, 1 number
     *  - array of 3 numbers, 1 number
     *  Also, any of these sets of arguments can be passed as a single argument, packed into array
     *  @function
     *  @return {this}                      this, for chaining
     */
    vertex: function () {
        var c    = this.__data__;
        var ctxt = { points: c.controlPoints, weights: c.weights };
        appendVertex(ctxt, toArray(arguments));
        c.controlPoints = ctxt.points;
        c.weights       = ctxt.weights;
        return this;
    }
});

/** Use {@link entities.surface} to construct
 *  @class
 *  @extends Sheet
 *  @classdesc Entity which represents NURBS surface
 */
function Surface() { Sheet.apply(this, arguments); }
// inherit Surface from Sheet
inherit(Surface, Sheet,
/** @lends Surface.prototype */
{
    /** Appends numbers to array of U-axis knots
     *
     *  @function
     *  @param  {...number} knot - knot values
     *  @return {this}             this, for chaining
     */
    uKnots: appendToField('uKnots'),
    /** Appends numbers to array of V-axis knots
     *
     *  @function
     *  @param  {...number} knot - knot values
     *  @return {this}             this, for chaining
     */
    vKnots: appendToField('vKnots'),
    /** Appends separate row (along surface's U axis) of control points to surface
     *
     *  @function
     *  @param  {...any} point - control points; for supported point representations, see {@link Curve#vertex}, except each vertex is passed as a single argument
     *  @return {this}           this, for chaining
     */
    row: function() {
        var c    = this.__data__;
        var ctxt = { points: [], weights: c.weights };

        for (var i = 0, e = arguments.length; i < e; ++i)
            appendVertex(ctxt, toArray(arguments[i]));

        c.controlPoints.push(ctxt.points);
        c.weights = ctxt.weights;
        return this;
    },
    /** Appends multiple rows of control points to surface
     *
     *  @function
     *  @param  {...any[]} row - rows of control points; see {@link Surface#row} for exact row structure
     *  @return {this}           this, for chaining
     */
    points: function() {
        for (var i = 0, e = arguments.length; i < e; ++i)
            this.row.apply(this, arguments[i]);
        return this;
    }
});

//******************************************************************************
/** Use functions from {@link constraints} to construct
 *  @class
 *  @classdesc Represents constraint in Flux protocol. These objects are added to the 'Constraints' part of scene
 */
function Constraint(id) { this.type = id; }

/** JSON representation of constraint
 *  Adds support for {@link JSON.stringify}
 *
 *  @return {*} JSON object
 */
Constraint.prototype.toJSON = function () {
    return this.__data__;
};

/** Helper function

    @private
    @param  {string}   typeid  - name of constraint type, value for 'type' property
    @param  {any}      params  - additional parameters of constraint
    @return {Constraint}         Constraint
*/
function type(typeid, params) {
    var e = new Constraint(typeid);
    e.__data__ = params;
    e.__data__.type = typeid;
    e.__data__.id = guid();
    return e;
}

//******************************************************************************
/** Use functions from {@link variables} to construct
 *  @class
 *  @classdesc Represents variable in Flux protocol. These objects are added to the 'Variables' part of scene
 */
function Variable() {}

/** Helper function

    @private
    @param  {any}      params - parameters of variable
    @return {Variable}          Variable
*/
function variable(params) {
    var v = new Variable();
    v.__data__ = params;
    v.__data__.id = guid();
    return v;
}

/** JSON representation of variable
 *  Adds support for {@link JSON.stringify}
 *
 *  @return {*} JSON object
 */
Variable.prototype.toJSON = function () {
    return this.__data__;
};

//******************************************************************************
/** Use functions from {@link equations} to construct
 *  @class
 *  @classdesc Represents equation in Flux protocol. These objects are added to the 'Equations' part of scene
 */
function Equation() {}

/** Helper function

    @private
    @param  {any}      params - parameters of equation
    @return {Equation}          Equation
*/
function equation(params) {
    var e = new Equation();
    e.__data__ = params;
    e.__data__.id = guid();
    return e;
}

/** JSON representation of equation
 *  Adds support for {@link JSON.stringify}
 *
 *  @return {*} JSON object
 */
Equation.prototype.toJSON = function () {
    return this.__data__;
};

//******************************************************************************
/** Use functions from {@link operations} to construct
 *  @class
 *  @classdesc Encapsulates info about operation in DCM/Parasolid Worker protocol
 */
function Operation(id) {
    this.opcode = id;
}
/** Converts operation body to JSON
    Adds support for {@link JSON.stringify}

    @return {*} JSON-ready object
 */
Operation.prototype.toJSON = function () {
    var r = [this.opcode];
    var self = this;
    if (this.args) {
        this.args.forEach(function (v) {
            if (v instanceof Operation) {
                try {
                    var name = self.__resolver__(v); // check if that operation was already bound
                    if (name) {
                        r.push(name);
                    }
                    else {
                        v.__resolver__ = self.__resolver__;
                        r.push(v.toJSON());
                    }
                }
                finally {
                    v.__resolver__ = undefined;
                }
            }
            else if (v instanceof Entity) { // locate bound entity by name
                if (!self.__resolver__)
                    throw Error("No entity resolver provided");
                r.push(self.__resolver__(v));
            }
            else if (v.primitive !== undefined) {
                var eraw = entities.raw(v);
                if (!self.__resolver__)
                    throw Error("No entity resolver provided");
                r.push(self.__resolver__(eraw));
            }
            else {
                r.push(v);
            }
        });
    }
    return r;
};
// Helper, generates operation factory
function op(id, nargs) {
    return function() {
        var r = new Operation(id);
        r.args = toArray(arguments).slice(0, nargs);
        return r;
    };
}
//******************************************************************************
// Attributes
//******************************************************************************

/** Use {@link attributes.material} to construct
 *  @class
 *  @classdesc Material attribute
 */
function Material() { this.__data__ = { }; }
/** @lends Material.prototype */
Material.prototype = {
    constructor: Material,
    /** Returns "material" for attribute type name
     *  @return {string} "material"
     */
    type: function() { return "material"; },
    /** Converts material to JSON object. Adds support for {@link JSON.stringify}
     *  @return {*} JSON-ready object
     */
    toJSON: function() { return this.__data__; },
    /** Sets ambient, diffuse and specular color values
     *
     *  @function
     *  @param  {number} - red
     *  @param  {number} - green
     *  @param  {number} - blue
     *  @return {this}     this, for chaining
     */
    color: function (r, g, b) {
        return this.ambient(r, g, b).diffuse(r, g, b).specular(r, g, b).power(1);
    },
    /** Sets ambient color
     *
     *  @function
     *  @param  {number} - red
     *  @param  {number} - green
     *  @param  {number} - blue
     *  @return {this}     this, for chaining
     */
    ambient: function (r, g, b) {
        this.__data__.ambient = [r, g, b];
        return this;
    },
    /** Sets specular color
     *
     *  @function
     *  @param  {number} - red
     *  @param  {number} - green
     *  @param  {number} - blue
     *  @return {this}     this, for chaining
     */
    specular: function (r, g, b) {
        this.__data__.specular = [r, g, b];
        return this;
    },
    /** Sets diffuse color
     *
     *  @function
     *  @param  {number} - red
     *  @param  {number} - green
     *  @param  {number} - blue
     *  @return {this}     this, for chaining
     */
    diffuse: function (r, g, b) {
        this.__data__.diffuse = [r, g, b];
        return this;
    },
    /** Sets specular power
     *
     *  @function
     *  @param  {number} power
     *  @return {this}   this, for chaining
     */
    power: function (s) {
        this.__data__.power = s;
        return this;
    }
};

var attributes =
/** Attribute constructors.
 *  Attributes are added to entities via {@link Entity#attribute Entity.attribute}
 *  @namespace attributes
 */
{
    /** Constructs material attribute
     *  @function
     *  @return {Material}
     */
    material: function () { return new Material(); }
};

/** Sets entity attribute on either a list of entities, raw object or instance of entity.
 *
 *  @function
 *  @param  {entity} entity - entity to modify
 *  @param  {string} property   - property
  *  @param  {*} value   - value
 *  @return {*}                 - entity with attribute set
 */
var setEntityAttribute = function(entity, property, value) {
    if (Array.isArray(entity)) {
        return entity.map(function(elt) {
            setEntityAttribute(elt, property, value);
        });
    }
    if (!(entity instanceof Entity)) {
        // Rehydrate entity. This moves fields to the __data__ field, and attaches
        // entity methods.
        var ent = entities.raw(entity);
        ent.attribute(property, value);
        return ent.toJSON();
    } else {
        return entity.attribute(property, value);
    }
};

/** Gets entity attribute on either raw object or instance of entity.
 *
 *  @function
 *  @param  {Entity} entity - entity to query
 *  @param  {string} property   - property
 *  @return {*}                 - attribute value
 */
var getEntityAttribute = function(entity, property) {
    if (Array.isArray(entity)) {
        return entity.map(function(elt) {
            getEntityAttribute(elt, property);
        });
    }
    if (!(entity instanceof Entity)) {
        // Rehydrate entity. This moves fields to the __data__ field, and attaches
        // entity methods.
        return entity.attributes[property];
    } else {
        return entity.__data__.attributes[property];
    }
};


//******************************************************************************
// Utilities
//******************************************************************************
var utilities = {
    coords:coords,
    vecCoords:vecCoords,
    setEntityAttribute: setEntityAttribute,
    getEntityAttribute: getEntityAttribute
};

//******************************************************************************
// Entities
//******************************************************************************
// var entities is used for self-call
var entities =
/** Entity constructors
 *  @namespace entities
 */
{
    //******************************************************************************
    // Raw entity, specified directly as JSON
    //******************************************************************************
    /** Constructs entity object from raw data. No checks for primitive value, body being object etc.
     *
     *  @param  {*}      body - any JavaScript value
     *  @return {Entity}
     */
    raw: function(body) {
        var e = new Entity(body.primitive);
        e.__data__ = body;
        return e;
    },

    //******************************************************************************
    // Vector entity
    //******************************************************************************

    /** Constructs Vector entity
     *
     *  @function
     *  @param  {number[]|Vector} coords - vector coordinates
     *  @return {Vector}
     */
    vector: function (vec) {
        return primitive('vector', { coords: vecCoords(vec) }, Vector);
    },

    //******************************************************************************
    // Point entity
    //******************************************************************************

    /** Constructs point entity
     *
     *  @function
     *  @param  {number[]|Point} coords - array with point coordinates
     *  @param  {string}         name   - optional, entity id
     *  @return {Point}
     */
    point: function (pt, name) {
        return primitive('point', {
            point: coords(pt),
            id: name || guid()
        }, Point);
    },

    //******************************************************************************
    // Wire entities
    //******************************************************************************

    /** Constructs line entity
     *
     *  @function
     *  @param  {number[]|Point} start - starting point
     *  @param  {number[]|Point} end   - end point
     *  @param  {string}         name  - optional, entity id
     *  @return {Wire}          line entity
     */
    line: function (start, end, name) {
        return primitive('line', {
            start: coords(start),
            end: coords(end),
            startId: getId(start) || guid(),
            endId: getId(end) || guid(),
            id: name || guid()
        }, Wire);
    },
    /** Constructs polyline entity
     *
     *  @function
     *  @param  {...number[]|Point} point - a set of points forming polyline
     *  @return {Wire}                      polyline entity
     */
    polyline: function() {
        return primitive('polyline', {
            points: mapCoords(arguments)
        }, Wire);
    },
    /** Constructs arc entity
     *
     *  @function
     *  @param  {number[]|Point}    start  - start point
     *  @param  {number[]|Point}    middle - middle point
     *  @param  {number[]|Point}    end    - end point
     *  @param  {string}            name   - optional, entity id
     *  @return {Wire}              arc entity
     */
    arc: function (start, middle, end, name) {
        return primitive('arc', {
            start: coords(start),
            middle: coords(middle),
            end: coords(end),
            startId: getId(start) || guid(),
            endId: getId(end) || guid(),
            originId: guid(),
            id: name || guid()
        }, Wire);
    },
    /** Constructs NURBS curve entity
     *
     *  @function
     *  @param  {number} degree - curve's NURBS degree
     *  @param  {string} name   - optional, entity id
     *  @return {Curve}           curve entity
     */
    curve: function(degree, name) {
        return primitive('curve', {
            degree: degree,
            knots: [],
            controlPoints: [],
            id: name || guid()
        },
        Curve);
    },
    /** Constructs circle entity
     *
     *  @function
     *  @param  {number[]|Point}    center - circle center
     *  @param  {number}            r      - radius
     *  @param  {string}            name   - optional, entity id
     *  @return {Wire}            circle entity
     */
    circle: function (center, r, name) {
        return primitive('circle', {
            origin: coords(center),
            originId: getId(center) || guid(),
            radius: r,
            id: name || guid()
        },
        Wire);
    },
    /** Constructs ellipse entity
     *
     *  @function
     *  @param  {number[]|Point}  center
     *  @param  {number}          rMajor - major radius
     *  @param  {number}          rMinor - minor radius
     *  @param  {number[]|Vector} dir    - major direction
     *  @param  {string}          name   - optional, entity id
     *  @return {Wire}
     */
    ellipse: function (center, rMajor, rMinor, dir, name) {
        return primitive('ellipse', {
            origin: coords(center),
            originId: getId(center) || guid(),
            majorRadius: rMajor,
            minorRadius: rMinor,
            direction: vecCoords(dir),
            id: name || guid()
        },
        Wire);
    },
    /** Constructs rectangle entity
     *
     *  @function
     *  @param  {number[]|Point}  center
     *  @param  {number[]|Vector} span - length of the rectangle along its local x and y axes
     *  @return {Wire}
     */
    rectangle: function (center, span) {
        var c = vecCoords(span);
        if (c.length != 2) {
            throw Error("Expected rectangle dimensions to be 2-dimensional.");
        }
        return primitive('rectangle', { origin: coords(center), dimensions: c }, Wire);
    },
    /** Constructs polycurve entity
     *
     *  Polycurve may represent any wire body, including non-manifold and disjoint
     *
     *  @function
     *  @param  {Wire[]}  curves
     *  @return {Wire}
     */
    polycurve: function (curves) {
        return primitive('polycurve', { curves: curves }, Wire);
    },

    //******************************************************************************
    // Sheet entities
    //******************************************************************************

    /** Constructs polygon set
     *
     *  @function
     *  @return {PolygonSet} polygon set entity
     */
    polygonSet: function () {
        return primitive('polygonSet', { polygons: [] }, PolygonSet);
    },
    /** Constructs NURBS surface
     *
     *  @function
     *  @param  {number}  uDegree - NURBS degree along U parameter
     *  @param  {number}  vDegree - NURBS degree along V parameter
     *  @return {Surface}           NURBS surface entity
     */
    surface: function(uDegree, vDegree) {
        return primitive('surface', {
            uDegree: uDegree,
            vDegree: vDegree,
            uKnots: [],
            vKnots: [],
            controlPoints: []
        }, Surface);
    },
    /** Constructs polysurface entity
     *
     *  Polysurface may represent any sheet or solid body, including non-manifold and disjoint
     *
     *  @function
     *  @param  {Sheet[]}  surfaces
     *  @return {Sheet}
     */
    polysurface: function (surfaces) {
        return primitive('polysurface', { surfaces: surfaces }, Sheet);
    },

    //******************************************************************************
    // Solid entities
    //******************************************************************************

    /** Constructs 3D mesh
     *
     *  @function
     *  @return {Mesh} mesh entity
     */
    mesh: function () {
        return primitive('mesh', { vertices: [], faces: [] }, Mesh);
    },
    /** Constructs 3D solid block
     *
     *  @function
     *  @param  {number[]|Point}  center
     *  @param  {number[]|Vector} dimensions - block dimensions along axes
     *  @return {Solid}
     */
    block: function (center, span) {
        return primitive('block', { origin: coords(center), dimensions: vecCoords(span) }, Solid);
    },
    /** Constructs torus, lying in XY plane
     *
     *  @function
     *  @param  {number[]|Point} center
     *  @param  {number}         rMinor - minor radius
     *  @param  {number}         rMajor - major radius
     *  @return {Solid}
     */
    torus: function (center, minr, majr) {
        return primitive('torus', {
            origin:      coords(center),
            minorRadius: minr,
            majorRadius: majr
        }, Solid);
    },
    /** Constructs sphere
     *
     *  @function
     *  @param  {number[]|Point} center
     *  @param  {number}         radius
     *  @return {Solid}
     */
    sphere: function (c, r) {
        return primitive('sphere', { origin: coords(c), radius: r }, Solid);
    },
    /** Constructs cylinder
     *
     *  @function
     *  @param  {number[]|Point}  center    - center of cylinder's basement
     *  @param  {number}          radius
     *  @param  {number}          height
     *  @return {Solid}
     */
    cylinder: function (c, r, h) {
        return primitive('cylinder', {
            origin:    coords(c),
            radius:    r,
            height:    h
        }, Solid);
    },
    /** Constructs cone
     *
     *  @function
     *  @param  {number[]|Point}  center     - center of cone's basement
     *  @param  {number}          radius
     *  @param  {number}          height
     *  @param  {number}          phi        - semi-angle, in degrees
     *  @return {Solid}
     */
    cone: function (c, r, h, phi) {
        return primitive('cone', {
            origin:       coords(c),
            radius:       r,
            height:       h,
            semiAngle:    phi
        }, Solid);
    },

    //******************************************************************************
    // Other entities
    //******************************************************************************
    /** Constructs affine transformation matrix
     *
     *  @function
     *  @param  {number[]} [matrix] - initial matrix, default is identity matrix
     *  @return {Affine}              affine transformation matrix entity
     */
    affine: function (optMatrix) {
        optMatrix = optMatrix || [
             1, 0, 0, 0 ,
             0, 1, 0, 0 ,
             0, 0, 1, 0 ,
             0, 0, 0, 1
        ];
        return primitive('affineTransform', { mat: optMatrix }, Affine);
    },
    /** Constructs infinite plane
     *
     *  @function
     *  @param  {number[]|Point}  origin - in-plane point
     *  @param  {number[]|Vector} normal - plane's normal vector
     *  @return {Plane}
     */
    plane: function (o, n) {
        return primitive('plane', {
            origin: coords(o),
            normal: vecCoords(n)
        });
    }
};

//******************************************************************************
// Constraints
//******************************************************************************
// Helper functions to create json constraints
function constr1(e) {
    return { entity1: getId(e) };
}
function valueConstr1(val, e) {
    return { value: val, entity1: getId(e) };
}
function constr2(e1, e2) {
    return { entity1: getId(e1), entity2: getId(e2) };
}
function valueConstr2(val, e1, e2) {
    return { value: val, entity1: getId(e1), entity2: getId(e2) };
}
function helpConstr2(e1, e2, h1, h2) {
    return { entity1: getId(e1), entity2: getId(e2), help1: h1, help2: h2 };
}
function helpParamsConstr2(e1, e2, p1, p2) {
    return { entity1: getId(e1), entity2: getId(e2), helpParam1: p1, helpParam2: p2 };
}
function valueHelpConstr2(val, e1, e2, h1, h2) {
    return { value: val, entity1: getId(e1), entity2: getId(e2), help1: h1, help2: h2 };
}
function constr3(e1, e2, e3) {
    return { entity1: getId(e1), entity2: getId(e2), entity3: getId(e3) };
}
function help(param) {
    if (arguments.length !== 1)
        throw Error("Invalid help parameter " + JSON.stringify(arguments));
    if (Array.isArray(param)) {
        if(param.length !== 0 && param.length !== 3) {
            throw Error("Invalid help point " + JSON.stringify(param));
        }
        return param;
    }
    if (typeof param !== 'number')
        throw Error("Invalid help parameter " + JSON.stringify(param));
    return [param];
}
// var constraints is used for self-call
var constraints =
    /** Constraint constructors
    *  @namespace constraints
    */
{
    //******************************************************************************
    // Raw constraint, specified directly as JSON
    //******************************************************************************
    /** Constructs constraint object from raw data. No checks for type value, body being object etc.
     *
     *  @param  {*}      body - any JavaScript value
     *  @return {Constraint}
     */
    raw: function(body) {
        var c = new Constraint(body.type);
        c.__data__ = body;
        return c;
    },
    /** Constructs parallel constraint
     *  Defined only for geometries with a direction
     *  It implies that the directions of the geometries are parallel
     *
     *  @function
     *  @param  {Entity} e1     - first entity
     *  @param  {Entity} e2     - second entity
     *  @return {Constraint}      parallel constraint
     */
    parallel: function(e1, e2) {
        return type('parallel', constr2(e1, e2));
    },
    /** Constructs radius constraint
     *  Defined only for circles
     *
     *  @function
     *  @param  {Entity} val    - circle radius value
     *  @param  {Entity} e      - circle entity
     *  @return {Constraint}      radius constraint
     */
    radius: function(val, e) {
        return type('radius', valueConstr1(val, e));
    }
};
// Operations
//******************************************************************************
var ops =
/** Operation constructors
 *  This documentation isn't precise on argument and result types,
 *  because functions listed here effectively create operation objects.
 *  So functions here are documented in terms of types
 *  these operations require as arguments and produce as results.
 *  Due to operation nesting and use of direct string identifiers,
 *  each of these functions can receive {@link string}, {@link Operation}
 *  along with types listed in parameter description.
 *  And each of these functions produces {@link Operation} object.
 *  @namespace operations
 */
{
    /** identity pseudo-operation
     *  Returns its single argument
     *  Used in cases where some entity should be directly mapped to output
     *
     *  @function
     *  @param  {Entity} entry - any entity
     *  @return {Entity}       - entry, unchanged
     */
    identity: function(entry) {
        var r = new Operation('identity');
        r.args = [entry];
        r.toJSON = function () {
            return Operation.prototype.toJSON.call(this)[1];
        };
        return r;
    },
    /** 'list' operation
     *  Accepts arbitrary list of entity/operation arguments
     *  @function
     *  @param  {...Entity} arg - any entity or operation
     *  @return {Entity[]}        list of entities
     */
    list: function() {
        var r = new Operation('list');
        r.args = toArray(arguments);
        return r;
    },
    /** 'repr' operation
     *  Produces Brep object in desired format.
     *  "content" field, which contains actual data, is zip-packed and base64 encoded
     *  Format identifiers supported:
     *  - "x_b": Parasolid binary format
     *  - "x_t": Parasolid textual format
     *  @function
     *  @param  {string} format identifier
     *  @param  {Entity} entity which should be converted to BREP
     *  @return {Entity} BREP
     */
    repr: op('repr', 2),
    /** 'raw' operation
     *  Accepts operation name and variadic list of its arguments directly
     *  Use with caution, only when you know what you do
     *  @function
     *  @param  {string}    name - operation identifier
     *  @param  {...Entity} arg  - any entity or operation
     *  @return {Entity[]}         list of entities
     */
    raw: function() {
        var r = new Operation(arguments[0]);
        r.args = toArray(arguments).slice(1);
        return r;
    },
    /** 'union' operation
     *  Computes union of two geometries
     *  @function
     *  @param  {Sheet|Solid} left
     *  @param  {Sheet|Solid} right
     *  @return {Mesh}        union result
     */
    unite: op('union', 2),
    /** 'intersection' operation
     *  Computes intersection of two geometries
     *  @function
     *  @param  {Sheet|Solid} left
     *  @param  {Sheet|Solid} right
     *  @return {Mesh}        intersection result
     */
    intersect: op('intersection', 2),
    /** 'difference' operation
     *  Subtracts right geometry from the left one
     *  @function
     *  @param  {Sheet|Solid} left  - entity to subtract from
     *  @param  {Sheet|Solid} right - entity being subtracted from left
     *  @return {Mesh}                subtraction result
     */
    subtract: op('difference', 2),
    /** 'evalDist' operation
     *  Computes distance between two geometries
     *  @function
     *  @param  {Point|Wire|Sheet|Solid} left
     *  @param  {Point|Wire|Sheet|Solid} right
     *  @return {number}                 distance between entities
     */
    evalDist: op('evalDist', 2),
    /** 'transform' operation
     *  Transforms 3D entity using affine matrix
     *  @function
     *  @param  {Point|Wire|Sheet|Solid} entity          - entity to transform
     *  @param  {Affine}                 transformation  - 3D affine matrix
     *  @return {Point|Wire|Sheet|Solid}                   first argument, transformed
     */
    transform: op('transform', 2),
    /** 'evalMassProps' operation
     *  Computes mass properties of entity
     *
     *  @function
     *  @param  {Wire|Sheet|Solid} entity
     *  @return {MassProps}        mass properties; not defined in this module because cannot be used as query input
     */
    evalMassProps: op('evalMassProps', 1),
    /** 'trim' operation
     *  Trims surface with a curve
     *  @function
     *  @param  {Sheet} sheet - sheet to be trimmed
     *  @param  {Wire}  curve - closed curve which will trim surface (will be projected onto surface if not resides on it)
     *  @return {Sheet}         trimmed sheet
     */
    trim: op('trim', 2),
    /** 'crossSection' operation
     *  Sections solid or sheet body with surface
     *  The result is a piece of surface which forms section
     *  @function
     *  @param  {Solid|Sheet} body    - solid or sheet body to section
     *  @param  {Plane}       surface - plane or cylinder surface to section with
     *  @return {Sheet}                 resulting cross-section
     */
    crossSection: op('crossSection', 2),
    /** 'intersectBodyWithLine' operation
     *  Computes a list of points where line intersects faces of specified body
     *  Points are ordered by their position on the line, along line's main direction
     *  @function
     *  @param  {Sheet|Solid} body - solid or sheet body to intersect
     *  @param  {Wire}        line - intersection line
     *  @return {Point[]}            list of intersection points
     */
    intersectBodyWithLine: op('intersectBodyWithLine', 2),
    /** 'extrude' operation
     *  Extrudes body along direction, until second body is reached
     *  @function
     *  @param  {Point|Wire|Sheet} profile   - extruded profile
     *  @param  {Sheet|Solid}      bound     - bounding body
     *  @param  {Vector}           direction - extrusion direction
     *  @return {Mesh}
     */
    extrude: op('extrude', 3),
    /** 'extrudeWithDistance' operation
     *  Extrudes body along direction for a specified distance
     *  @function
     *  @param  {Point|Wire|Sheet} body      - extruded profile
     *  @param  {number}           distance  - 'height' of extrusion
     *  @param  {Vector}           direction - extrusion direction
     *  @return {Mesh}
     */
    extrudeWithDistance: op('extrudeWithDistance', 3),
    /** 'sweep' operation
     *  Sweeps wire or sheet profile along guide wire
     *  @function
     *  @param  {Wire[]|Sheet[]} profiles - profiles being swept
     *  @param  {Wire[]}         guides   - guide wires to sweep along
     *  @return {Mesh}
     */
    sweep: op('sweep', 2),
    /** 'loft' operation
     *  Lofts a set of profiles along a set of guide wires
     *  @function
     *  @param  {Wire[]|Sheet[]} profiles      - lofted profiles
     *  @param  {Wire[]}         guides        - lofting guides
     *  @param  {Point[]}        startVertices - starting vertices for lofted profiles
     *  @return {Mesh}
     */
    loft: op('loft', 3),
    /** 'revolve' operation
     *  Spins specified profile around axis based at origin for a specified angle
     *  @function
     *  @param  {Point|Wire|Sheet} profile - spinned profile
     *  @param  {Point}            origin  - rotation center
     *  @param  {Vector}           axis    - rotation axis, which is normal vector to rotation plane
     *  @param  {number}           angle   - spinning angle
     *  @return {Mesh}
     */
    revolve: op('revolve', 4),
    /** 'evalCurveLength' operation
     *  Computes curve length
     *  @function
     *  @param  {Curve}  curve
     *  @return {number}
     */
    evalCurveLength: op('evalCurveLength', 1),
    /** 'tessellate' operation
     *  Converts BREP body to a polygonal mesh
     *  @function
     *  @param  {Solid}    body              - body being tessellated
     *  @param  {number}  [linearTolearance] - the minimum linear size of any detail to be visible
     *  @param  {number}  [angularSize]      - the angle, in degrees, which provided body occupies in field of view
     *  @return {Mesh}
     */
    tesselate: function() {
        var r = new Operation('tessellate');
        r.args = [ arguments[0], arguments[1] || DEFAULT_LINEAR_TOLERANCE, arguments[2] || DEFAULT_ANGULAR_SIZE ];
        return r;
    },
    /** 'createPolylineApprox' operation
     *  Converts NURBS curve to polyline
     *  @function
     *  @param  {Curve}     curve
     *  @return {Point[]}
     */
    createPolylineApprox: op('createPolylineApprox', 1),
    /** 'mirror' operation
     *  Produces entity that reflected about given origin and direction
     *  @function
     *  @param  {Point|Wire|Sheet|Solid} body
     *  @param  {Point}                  origin
     *  @param  {Vector}                 direction
     *  @return {Point|Wire|Sheet|Solid}
     */
    mirror: op('mirror', 3),
    /** 'createLinearPattern' operation
     *  Produces linear pattern of entity in the given direction
     *  that is separated by spacing parameter
     *  @function
     *  @param  {Point|Wire|Sheet|Solid}  pattern
     *  @param  {Vector}                  direction
     *  @param  {number}                  spacing   - distance between pattern copies
     *  @param  {number}                  nEntities - repetitions count
     *  @return {Point|Wire|Sheet|Solid}
     */
    createLinearPattern: op('createLinearPattern', 4),
    /** 'createCircularPattern' operation
     *  Produces circular pattern of entity in the given direction
     *  that is separated by angle between each instance
     *  @function
     *  @param  {Point|Wire|Sheet|Solid}  pattern
     *  @param  {Point}                   origin
     *  @param  {Vector}                  direction - direction vector in which to create patterns
     *  @param  {number}                  angle     - angle between instances
     *  @param  {number}                  nEntities - repetitions count
     *  @return {Point|Wire|Sheet|Solid}
     */
    createCircularPattern: op('createCircularPattern', 5),
    /** 'createPlanarSheet' operation
     *  Creates a sheet body from a closed curve
     *  @function
     *  @param  {Wire}  curve - closed curve
     *  @return {Sheet}
     */
    createPlanarSheet: op('createPlanarSheet', 1),
     /** 'sectionBody' operation
     *  Sections a body with a plane or a sheet
     *  @function
     *  @param  {Sheet|Solid} target
     *  @param  {Sheet|Plane} tool
     *  @return {Sheet|Solid} the piece of original body from 'back' tool side (opposite to where tool's normal points)
     */
    sectionBody: op('sectionBody', 2),
    /** 'joinCurves' operation
     *  Joins a closed set of wires to form a solitary wire
     *  @function
     *  @param  {...Wire} wire
     *  @return {Wire}
     */
    joinCurves: op('joinCurves', 1),
    /** 'evalCurve' operation
     *  Evaluates a point and derivatives at a given curve parameter
     *  For b-curves, the parameter space is bound by the lowest and highest value in the knot vector.
     *  For other wires parameter spaces are preset as follows:
     *   - Line      - [0, 1]
     *   - Polyline  - [0, 1]
     *   - Rectangle - [0, 1]
     *   - Arc       - [0, 1]
     *   - Circle    - [0, 2Pi]
     *   - Ellipse   - [0, 2Pi]
     *  Circles and ellipses are always periodic, so it is possible to pass values beyond this interval.
     *  @function
     *  @param  {Curve}   curve
     *  @param  {number}  t       - parameter on curve
     *  @param  {number}  nDerivs - number of derivatives
     *  @return {Point[]}           a point and N derivatives
     */
    evalCurve: op('evalCurve', 3),
    /** 'evalSurface' operation
     *  Evaluates a point and derivatives at a given surface parameter pair
     *  @function
     *  @param  {Sheet}   surface
     *  @param  {number}  u        - surface parameter
     *  @param  {number}  v        - surface parameter
     *  @param  {number}  nUDerivs - derivatives count along U parameter
     *  @param  {number}  nVDerivs - derivatives count along V parameter
     *  @return {Point[]}            result point and its nU*nV-1 derivatives
     */
    evalSurface: op('evalSurface', 5),
    /** 'makeSubCurve' operation
     *  Creates a curve based on an existing curve's parameter interval
     *  For b-curves, the parameter space is bound by the lowest and highest value in the knot vector.
     *  For other wires parameter spaces are preset as follows:
     *   - Line      - [0, 1]
     *   - Polyline  - [0, 1]
     *   - Rectangle - [0, 1]
     *   - Arc       - [0, 1]
     *   - Circle    - [0, 2Pi]
     *   - Ellipse   - [0, 2Pi]
     *  Circles and ellipses are always periodic, so it is possible to pass values beyond this interval.
     *  @function
     *  @param  {Curve}  curve
     *  @param  {number} t0    - subrange start
     *  @param  {number} t1    - subrange end
     *  @return {Curve}          sub-curve from t0 to t1
     */
    makeSubCurve: op('makeSubCurve', 3),
    /** 'makeSubSurface' operation
     *  Creates a sub-surface based on an existing surface's parameter box
     *  @function
     *  @param  {Sheet}  surface
     *  @param  {number} u0 - U subrange start
     *  @param  {number} u1 - U subrange end
     *  @param  {number} v0 - V subrange start
     *  @param  {number} v1 - V subrange end
     *  @return {Sheet}       sub-sheet in ([u0, u1], [v0, v1]) box
     */
    makeSubSurface: op('makeSubSurface', 5),
    /** 'intersectCurves' operation
     *  Finds all intersections between two curves
     *  @function
     *  @param  {Curve}   curve1
     *  @param  {Curve}   curve2
     *  @return {Point[]} intersections list
     */
    intersectCurves: op('intersectCurves', 2),
    /** 'offsetBody' operation
     *  'Bloats' sheet or solid body by offsetting all its faces by specified distance, using faces' normals as directions
     *  @function
     *  @param  {Sheet|Solid} body
     *  @param  {number}      distance
     *  @return {Sheet|Solid}
     */
    offsetBody: op('offsetBody', 2),
    /** 'offsetWire' operation
     *  'Bloats' planar wire body by offsetting its pieces by specified distance
     *  @function
     *  @param  {Wire}   wire     - wire, must lie in one plane
     *  @param  {number} distance - distance to offset
     *  @param  {Vector} normal   - normal to wire's plane
     *  @return {Wire}
     */
    offsetWire: op('offsetWire', 3),
    /** 'createProfiles' operation
     *  Creates a wire or sheet body from a set of wires
     *  @function
     *  @param  {Wire[]}     profiles
     *  @param  {number}     sheetFlag - 0 for wire result, otherwise sheet
     *  @return {Wire|Sheet}             cannot be exported, only usable as input for other operations
     */
    createProfiles: op('createProfiles', 2),
    /** 'compareCurves' operation
     *  Checks if two NURBS curves are equal
     *  Following wires are considered NURBS geometry: lines, polylines, arcs, curves, rectangles.
     *  Returns "1" if wires have equal knots, points and degrees, "0" otherwise.
     *  @function
     *  @param  {Curve}   curve1
     *  @param  {Curve}   curve2
     *  @return {Number}  "1" if equal, "0" otherwise
     */
    compareCurves: op('compareCurves', 2),
    /** 'createResilientProfiles' operation
     *  Creates profiles which inner loops are removed
     *  @function
     *  @param  {Wire[]}  profiles
     *  @return {Sheet}   profile
     */
    createResilientProfiles: op('createResilientProfiles', 1),
    /** 'eval' operation
     *  Evaluates entire scene inside DCM-Worker
     *  @function
     *  @return {DCM/Scene} scene
     */
    eval: function() {
        return new Operation('eval');
    }
};

// Helper function
function getCircleCenterByThreePoints(start, middle, end)
{
    // All z-coords are taken to be 0
    // Not valid for real 3d arc

    var offset = Math.pow(middle[0], 2) + Math.pow(middle[1], 2);
    var bc = (Math.pow(start[0], 2) + Math.pow(start[1], 2) - offset) / 2.0;
    var cd = (offset - Math.pow(end[0], 2) - Math.pow(end[1], 2)) / 2.0;
    var det = (start[0] - middle[0]) * (middle[1] - end[1]) - (middle[0] - end[0]) * (start[1] - middle[1]);
    if (Math.abs(det) < eps) {
        throw Error("Cannot get circle center by three points [" +
            start[0] + ", " + start[1] + "], [" + middle[0] + ", " +
            middle[1] + "], [" + end[0] + ", " + end[1] + "]");
    }
    var idet = 1.0/det;

    var centerX =  (bc * (middle[1] - end[1]) - cd * (start[1] - middle[1])) * idet;
    var centerY =  (cd * (start[0] - middle[0]) - bc * (middle[0] - end[0])) * idet;

    return [centerX, centerY, 0.0];
}
return {
    gen_id_object: gen_id_object,
    scene: scene,
    dcmScene: dcmScene,
    attributes: attributes,
    utilities: utilities,
    entities: entities,
    constraints: constraints,
    operations: ops
}
});}(typeof define==='function'&&define.amd?define:function(factory){module.exports=factory(require);}));