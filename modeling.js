/** @file Helper functions and classes to generate valid JSON queries to Geometry Worker server.
 *  Use {@link query} as a starting point
 *  @author Igor Baidiuk <ibaidiuk@amcbridge.com>
 */

/* jslint node:true */

/***************************************************************************************************
 *  Constructs new instance for current module
 */
function constructModule(config) {
"use strict";
/***************************************************************************************************
 *  Configuration part
 */
var flux = require('./index');
config = config || {};
if (typeof config !== 'object') {
    throw new FluxModelingError("config: expected object");
}


var flux = require('./index');
var types, s;

// Skip require for environments that don't support it (rollup)
if (!config.skip) {
    // If a user of modelingjs is explicitly passing a falsey value for genId,
    // then default to a function that returns undefined, to avoid errors attempting
    // to call a null value downstream.
    var genId =  config['genId'] ||  function () { return undefined; };

    var convertUnits = (function () {
        var registry = 'registry' in config ? config['registry'] : new flux.measure.Registry();
        return registry
            ? registry.ConvertUnits.bind(registry)
            : function (obj, dimUnits) { return obj; };
    })();
    types = require("./types")();
    // Schema helpers
    s = types.helpers;
}

var eps = 1e-8;
var DEFAULT_LINEAR_TOLERANCE = 0.1;
var DEFAULT_ANGULAR_SIZE     = 30.0;

var util = require("./util");

/* Converts any array-like object to actual array
   Used mostly with Arguments objects
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj);
}

function normalize(arr) {
    var m = Math.sqrt(arr[0]*arr[0] + arr[1]*arr[1]  + arr[2]*arr[2]);
    return [arr[0]/m, arr[1]/m, arr[2]/m];
}

function initObject(dest, source) {
    if (typeof source !== "object")
        throw new Error("source: expected object");
    if (typeof dest !== "object")
        throw new Error("dest: expected object");
    for (var key in source)
        dest[key] = source[key];
}

function mapObject(source, lambda) {
    if (typeof source !== "object")
        throw new Error("source: expected object");
    if (typeof lambda !== "function")
        throw new Error("lambda: expected object");

    var dest = {};
    for (var key in source)
        dest[key] = lambda(key, source[key]);
    return dest;
}

//******************************************************************************
// Resolver becoming kind of scope stuff

var queryResolver = function () { return undefined; };

function resolve(item) {
    return queryResolver(item);
}

function withResolver(resolver, lambda) {
    var prev = queryResolver;
    queryResolver = resolver;
    try {
        return lambda();
    }
    finally {
        queryResolver = prev;
    }
}

//******************************************************************************
// Type declarations
//******************************************************************************
/** Use factory function {@link query}
 *  @class
 *  @classdesc Represents block query as query, with geometrical entities and operations over there
 */
function Query() {
    this.entities   = {};
    this.operations = [];

    var counter = 1;
    this.generateName = function (prefix) {
        var name = prefix + '@' + counter;
        counter += 1;
        return name;
    };
}
/** Creates new query object
 *
 *  @return {Query} new empty query object
 */
var query = function () { return new Query(); };
/** Converts Query object to JSON representation
 *  Adds custom-conversion support for {@link JSON.stringify}
 *
 *  @return {*} JSON-ready object
 */
Query.prototype.toJSON  = function () {
    var ops = dumpOperations(this);
    return {
        Entities:   this.entities,
        Operations: ops
    };
};
/* Resolves Entity or Operation object into its name in query
   Entities without a name are assigned with autogenerated name
   Operations without a name return no name and thus expanded in-place

   @param  {Entity|Operation} object - to be resolved
   @param  {number}           index  - index of current operation block, used to block forward lookups
   @return {string}                    item name, if any
 */
function resolveItem(self, e, opIndex) {
    var key;
    if (isEntity(e)) {
        Object.keys(self.entities).forEach(function (k) {
            if (!key && self.entities[k] === e) {
                key = k;
            }
        });
        if (!key) {
            key = self.generateName(e.primitive);
            self.entities[key] = e;
        }
        return key;
    }
    else if (e instanceof Operation) {
        var ops = self.operations;
        var i;

        // find latest binding
        for (i = opIndex - 1; i >= 0; i -= 1) {
            var item = ops[i];
            if (item.operation === e) {
                key = item.name;
                break;
            }
        }
        // check if binding wasn't overridden later
        if (key)
            for (var j = opIndex - 1; j > i; j -= 1)
                if (ops[j].name === key)
                    return undefined;

        return key;
    }
}


function dumpOperations(self) {
    function resolver(index) {
        return function(e) { return resolveItem(self, e, index); };
    }

    return self.operations.map(
        function (item, index) {
            return withResolver(
                resolver(index),
                function () {
                    return item.toJSON();
                }
            );
        }
    );
}

/*  @class
    @classdesc Named operation slot
 */
function OpSlot(name, op) {
    this.name = name;
    this.operation = op;
}
OpSlot.prototype.toJSON = function () {
    return {
        name: this.name,
        op:   this.operation.toJSON()
    };
};

/** Adds entity/operation to query
 *
 *  @param  {string}             name - name of item being added
 *  @param  {Entity|Operation}   obj  - either entity or operation being added
 *  @return {this}                      this, for chaining
 */
Query.prototype.add = function(name, obj) {
    if (typeof name !== 'string')
        throw new FluxModelingError('name: string expected');
    if (isEntity(obj)) {
        if (this.entities[name] !== undefined)
            throw new FluxModelingError('entity "' + name + '" already defined');
        this.entities[name] = obj;
    }
    else if (obj instanceof Operation) {
        this.operations.push(new OpSlot(name, obj));
    }
    else if (Array.isArray(obj)) { // Raw operation
        this.add(name, operations.raw(obj));
    }
    else
        throw new FluxModelingError('obj: either Entity or Operation is expected');
    return this;
};

/** Helper function

    @private
    @param  {string}   typeid  - name of entity type, value for 'primitive' property
    @param  {any}      params  - additional parameters of entity
    @return {Entity}             Entity or any other type specified by OptCtor
*/
function primitive(typeid, params) {
    var e = {primitive: typeid};
    initObject(e, params);
    e.primitive = typeid;
    e.units = types.measure.defaultUnits(typeid);
    return e;
}

/** Helper function to defermine if an object is an entity. Does not validate
    the entity.
    @private
    @param  {object}   object  - potential entity
    @return {bool}             Entity or any other type specified by OptCtor
*/
function isEntity(obj) {
    return obj.primitive != null;
}

/** Helper function to extract point coordinates

    @private
    @param  {any}   obj  - entity or array
    @return {Array}             Coordinate array
*/
function makeAdjustCoords(primitive, field) {
    return function coords(obj) {
        if (Array.isArray(obj))
            return obj;

        if (isEntity(obj)) {
            if (obj.units &&
                obj.units[field] != types.measure._defaultDimToUnits.length) {
                obj = convertUnits(obj, types.measure._defaultDimToUnits);
            }

            if (obj.primitive === primitive) {
                return obj[field];
            }
        }
        throw new FluxModelingError("expected array of numbers or " + primitive + " entity");
    };
}

var coords = makeAdjustCoords("point", "point");

function mapCoords(vec) {
    var out = [];
    for (var i = 0, e = vec.length; i < e; ++i)
        out.push(coords(vec[i]));
    return out;
}

/** Helper function to extract vector components

    @private
    @param  {any}   obj  - entity or array
    @param  {string} [dimToUnits] - optional, desired units of resulting
        vector. Only used if the input object is an entity, and if this module
        has been init'd with a units of measure registry.
    @return {Array}             Component array
*/

var vecCoords = makeAdjustCoords("vector", "coords");

function mapVecCoords(vec) {
    var out = [];
    for (var i = 0, e = vec.length; i < e; ++i)
        out.push(vecCoords(vec[i]));
    return out;
}

// Multiply 2 matrices
function multMatrix(a, b) {
    var len = a.length;

    var c = new Array(len);
    var i;

    var dim = Math.sqrt(len);

    for (i = 0; i < dim; ++i)
        for (var j = 0; j < dim; ++j) {
            var s = 0;
            for (var k = 0 ; k < dim; ++k)
                s += a[i * dim + k] * b[k * dim + j];
            c[i * dim + j] = s;
        }
    return c;
}

//******************************************************************************
/** Use functions from {@link operations} to construct
 *  @class
 *  @classdesc Encapsulates info about operation in DCM/Parasolid Worker protocol
 */
function Operation(id) {
    this.opcode = id;
}
/** Converts operation body to JSON
    Adds support for {@link JSON.stringify}

    @return {*} JSON-ready object
 */
Operation.prototype.toJSON = function () {
    var r = (this.args || []).map(function (item) {
        if (item instanceof Operation)
            return resolve(item) || item.toJSON();
        if (isEntity(item)) {
            var entity = resolve(item);
            if (!entity)
                throw Error("Failed to resolve entity object");
            return entity;
        }

        return item;
    });
    r.unshift(this.opcode);
    return r;
};
// Helper, generates operation factory
function op(id, nargs) {
    return function() {
        var r = new Operation(id);
        var args = toArray(arguments);
        if (args.length != nargs) {
            throw new Error("Expected "+nargs+ "arguments", "got "+args.length);
        }
        r.args = args.slice(0, nargs);
        return r;
    };
}
//******************************************************************************
// Attributes
//******************************************************************************
// TODO(andrew): consider making these return a cloned and modified entity,
// rather than mutating the passed entity.

/** Sets entity attribute on either a list of entities, raw object or instance of entity.
 *
 *  @function
 *  @param  {entity} entity - entity to modify
 *  @param  {string} property   - property
  *  @param  {*} value   - value
 *  @return {*}                 - entity with attribute set
 */
var setEntityAttribute = function(entity, property, value) {
    if (Array.isArray(entity)) {
        return entity.map(function(elt) {
            setEntityAttribute(elt, property, value);
        });
    }

    entity.attributes = entity.attributes || {};
    entity.attributes[property] = value;
};

/** Gets entity attribute on either raw object or instance of entity.
 *
 *  @function
 *  @param  {Entity} entity - entity to query
 *  @param  {string} property   - property
 *  @return {*}                 - attribute value
 */
var getEntityAttribute = function(entity, property) {
    if (Array.isArray(entity)) {
        return entity.map(function(elt) {
            getEntityAttribute(elt, property);
        });
    }
    return (entity.attributes || {})[property];
};

//******************************************************************************
// Utilities
//******************************************************************************
var utilities = {
    coords:coords,
    vecCoords:vecCoords,
    setEntityAttribute: setEntityAttribute,
    getEntityAttribute: getEntityAttribute,
};

//******************************************************************************
// Entities
//*****************************∂chec*************************************************
// var entities is used for self-call
var entities =
/** Entity constructors
 *  @namespace entities
 */
{
    //******************************************************************************
    // Vector entity
    //******************************************************************************

    /** Constructs Vector entity
     *
     *  @function
     *  @param  {number[]|Vector} coords - vector coordinates
     *  @return {Vector}
     */
    vector: function (vec) {
        types.checkAllAndThrow(
            ["Components", s.AnyOf(s.Type("position"), s.Entity("vector")), vec])
        return primitive('vector', { coords: vecCoords(vec) });
    },

    //******************************************************************************
    // Point entity
    //******************************************************************************

    /** Constructs point entity
     *
     *  @function
     *  @param  {number[]|Point} point - array with point coordinates
     *  @param  {string}         [id]   - optional, entity id
     *  @return {Point}
     */
    point: function (point, id) {
        types.checkAllAndThrow(
            ["Point", s.AnyOf(s.Type("position"), s.Entity("point")), point],
            ["Id", s.Maybe(s.String), id]);
        return primitive('point', {
            point: coords(point),
            id: id || genId()
        });
    },

    //******************************************************************************
    // Wire entities
    //******************************************************************************

    /** Constructs line entity
     *
     *  @function
     *  @param  {number[]|Point} start - starting point
     *  @param  {number[]|Point} end   - end point
     *  @param  {string}         [id]  - optional, entity id
     *  @return {Wire}          line entity
     */
    line: function (start, end, id) {
        types.checkAllAndThrow(
            ["Start", s.AnyOf(s.Type("position"), s.Entity("point")), start],
            ["End", s.AnyOf(s.Type("position"), s.Entity("point")), end],
            ["Id", s.Maybe(s.String), id ]);
        return primitive('line', {
            start:   coords(start),
            end:     coords(end),
            startId: start.id || genId(),
            endId:   end.id || genId(),
            id:      id || genId()
        });
    },
    /** Constructs polyline entity
     *
     *  @function
     *  @param  {...number[]|Point} point - a set of points forming polyline
     *  @return {Wire}                      polyline entity
     */
     // TODO(andrew): add typechecking to polyline. Consider passing an array of
     // of points as a single arguement, rather than processing the array of
     // arguments.
    polyline: function() {
        return primitive('polyline', {
            points: mapCoords(arguments)
        });
    },
    /** Constructs arc entity
     *
     *  @function
     *  @param  {number[]|Point}    start  - start point
     *  @param  {number[]|Point}    middle - middle point
     *  @param  {number[]|Point}    end    - end point
     *  @param  {string}            [id]   - optional, entity id
     *  @return {Wire}              arc entity
     */
    arc: function (start, middle, end, id) {
        types.checkAllAndThrow(
            ["Start", s.AnyOf(s.Type("position"), s.Entity("point")), start],
            ["Middle", s.AnyOf(s.Type("position"), s.Entity("point")), middle],
            ["End", s.AnyOf(s.Type("position"), s.Entity("point")), end],
            ["Id", s.Maybe(s.String), id]);
        return primitive('arc', {
            start:    coords(start),
            middle:   coords(middle),
            end:      coords(end),
            startId:  start.id || genId(),
            endId:    end.id || genId(),
            originId: genId(),
            id:       id || genId()
        });
    },
    /** Constructs NURBS curve entity
     *
     *  @function
     *  @param  {number} degree - curve's NURBS degree
     *  @param  {string} [id]   - optional, entity id
     *  @return {Curve}           curve entity
     */
    curve: function(degree, controlPoints, knots, weights, id) {
        types.checkAllAndThrow(
            ["Degree", s.PositiveInteger, degree],
            ["ControlPoints", s.ArrayOf(s.AnyOf(s.Entity("point"), s.Type("position"))), controlPoints],
            ["Knots", s.ArrayOf(s.Number), knots],
            ["Weights", s.Maybe(s.ArrayOf(s.Number)), weights],
            ["Id", s.Maybe(s.String), id]);

        if (knots.length != controlPoints.length + degree + 1) {
            throw Error("Expect number of input knots (" + knots.length +
                ") to equal the number of control points (" + controlPoints.length +
                ") the degree of the curve (" + degree +
                ")+ 1, which is "+(controlPoints.length + degree + 1));
        }

        if (weights && weights.length != controlPoints.length) {
            throw Error("Expect weights to have length (got "+ weights.length +
                        ") that is the same as controlPoints (got " + controlPoints.Length +
                        ").");
        }

        return primitive('curve', {
            degree: degree,
            knots: knots,
            controlPoints: mapCoords(controlPoints),
            weights: weights,
            id: id || genId()
        });
    },
    /** Constructs circle entity
     *
     *  @function
     *  @param  {number[]|Point}    center - circle center
     *  @param  {number}            r      - radius
     *  @param  {string}            [id]   - optional, entity id
     *  @return {Wire}            circle entity
     */
    circle: function (center, r, id) {
        types.checkAllAndThrow(
            ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), center],
            ["Radius", s.Type("distance"), r],
            ["Id", s.Maybe(s.String), id]);
        return primitive('circle', {
            origin:   coords(center),
            originId: center.id || genId(),
            radius:   r,
            id:       id || genId()
        });
    },
    /** Constructs ellipse entity
     *
     *  @function
     *  @param  {number[]|Point}  center
     *  @param  {number}          majorRadius - major radius
     *  @param  {number}          minorRadius - minor radius
     *  @param  {number[]|Vector} dir    - major direction
     *  @param  {string}          [id]   - optional, entity id
     *  @return {Wire}
     */
    ellipse: function (center, majorRadius, minorRadius, direction, id) {
        types.checkAllAndThrow(
            ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), center],
            ["MajorRadius", s.Type("distance"), majorRadius],
            ["MinorRadius", s.Type("distance"), minorRadius],
            ["Direction", s.AnyOf(s.Type("position"), s.Entity("vector")), direction],
            ["Id", s.Maybe(s.String), id]);
        return primitive('ellipse', {
            origin:      coords(center),
            originId:    center.id || genId(),
            majorRadius: majorRadius,
            minorRadius: minorRadius,
            direction:   (direction ? vecCoords(direction) : undefined),
            id:          id || genId()
        });
    },
    /** Constructs rectangle entity
     *
     *  @function
     *  @param  {number[]|Point}  center
     *  @param  {number[]|Vector} span - length of the rectangle along its local x and y axes
     *  @return {Wire}
     */
    rectangle: function (center, span) {
        types.checkAllAndThrow(
            ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), center],
            ["Span", s.AnyOf(s.ArrayOf(s.Number), s.Entity("vector")), span]);
        var c = vecCoords(span);
        if (c.length != 2) {
            throw new FluxModelingError("Expected rectangle dimensions to be 2-dimensional.");
        }
        return primitive('rectangle', { origin: coords(center), dimensions: c });
    },
    /** Constructs polycurve entity
     *
     *  Polycurve may represent any wire body, including non-manifold and disjoint
     *
     *  @function
     *  @param  {Wire[]}  curves
     *  @return {Wire}
     */
    polycurve: function (curves) {
        types.checkAllAndThrow(
            ["Curves", s.ArrayOf(s.Entity("curve")), curves]);
        return primitive('polycurve', { curves: curves });
    },

    //******************************************************************************
    // Sheet entities
    //******************************************************************************

    /** Constructs NURBS surface
     *
     *  @function
     *  @param  {number}  uDegree - NURBS degree along U parameter
     *  @param  {number}  vDegree - NURBS degree along V parameter
     *  @return {Surface}           NURBS surface entity
     */
    surface: function(uDegree, vDegree, controlPoints, uKnots, vKnots, weights) {
        types.checkAllAndThrow(
            ["UDegree", s.PositiveInteger, uDegree],
            ["VDegree", s.PositiveInteger, vDegree],
            ["ControlPoints", s.ArrayOf(
                s.ArrayOf(s.AnyOf(s.Entity("point"), s.Type("position")))), controlPoints],
            ["UKnots", s.ArrayOf(s.Number), uKnots],
            ["VKnots", s.ArrayOf(s.Number), vKnots],
            ["Weights", s.Maybe(s.ArrayOf(s.ArrayOf(s.Number))), weights]);
        var M = controlPoints.length;
        var N = controlPoints[0].length;

        if (uKnots.length != M + uDegree + 1) {
            throw Error("In the u-direction, expect number of input knots (" + uKnots.length +
                ") to equal the number of control points (" + M +
                ") the degree of the curve (" + uDegree +
                ") + 1, which is "+ (M + uDegree + 1));
        }
        if (vKnots.length != N + vDegree + 1) {
            throw Error("In the v-direction, expect number of input knots (" + vKnots.length +
                ") to equal the number of control points (" + N +
                ") the degree of the curve (" + vDegree +
                ") + 1, which is "+ (N + vDegree + 1));
        }

        // Check that all rows have the right length and unpack point entities
        // into their coordinate vectors.
        for (var i = 0; i < controlPoints.length; i++) {
            var row = controlPoints[i];
            if(row.length != N) {
                throw Error("Not all rows of control points are of equal length. Got " + row.length +
                    " but expected " + N);
            }
            controlPoints[i] = mapCoords(row);
        }

        // TODO(andrew): assert that weights have the same shape as controlPoints.

        return primitive('surface', {
            uDegree: uDegree,
            vDegree: vDegree,
            uKnots: uKnots,
            vKnots: vKnots,
            controlPoints: controlPoints,
            weights: weights
        });
    },
    /** Constructs polysurface entity
     *
     *  Polysurface may represent any sheet or solid body, including non-manifold and disjoint
     *
     *  @function
     *  @param  {Sheet[]}  surfaces
     *  @return {Sheet}
     */
    polysurface: function (surfaces) {
        types.checkAllAndThrow(
            ["Surfaces", s.ArrayOf(s.Entity("surface")), surfaces]);
        return primitive('polysurface', { surfaces: surfaces });
    },

    //******************************************************************************
    // Solid entities
    //******************************************************************************

    /** Constructs 3D mesh
     *
     *  @function
     *  @return {Mesh} mesh entity
     */
    mesh: function (vertices, faces) {
        types.checkAllAndThrow(
            ["Vertices", s.ArrayOf(s.AnyOf(s.Entity("point"), s.Type("position"))), vertices],
            ["Faces", s.ArrayOf(s.ArrayOf(s.Type("index"))), faces]);
        return primitive('mesh', { vertices: mapCoords(vertices), faces: faces });
    },
    /** Constructs 3D solid block
     *
     *  @function
     *  @param  {number[]|Point}  center
     *  @param  {number[]|Vector} dimensions - block dimensions along axes
     *  @return {Solid}
     */
    block: function (center, span) {
        types.checkAllAndThrow(
            ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), center],
            ["Dimensions", s.AnyOf(s.Type("position"), s.Entity("vector")), span]);
        return primitive('block', { origin: coords(center), dimensions: vecCoords(span) });
    },

    /** Constructs sphere
     *
     *  @function
     *  @param  {number[]|Point} center
     *  @param  {number}         radius
     *  @return {Solid}
     */
    sphere: function (c, r) {
        types.checkAllAndThrow(
            ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), c],
            ["Radius", s.Type("distance"), r]);
        return primitive('sphere', { origin: coords(c), radius: r });
    },

    //******************************************************************************
    // Other entities
    //******************************************************************************
    affine: {
        /** Constructs affine transformation matrix
         *
         *  @function
         *  @param  {number[]} matrix - initial matrix
         *  @return {Affine}              affine transformation matrix entity
         */
        byMatrix: function(matrix) {
            types.checkAllAndThrow(
                ["Matrix", s.ArrayOf(s.Number), matrix])
            return primitive('affineTransform', { mat: matrix });
        },
        /** Compose two transformations
         *
         *  @function
         *  @param  {number[]|Affine} [a] - first matrix
         *  @param  {number[]|Affine} [b] - second matrix
         *  @return {Affine}              affine transformation matrix entity
         */
        byComposition: function(a, b) {
            //TODO(andrew): make sure that both matrices have the same units.
            // Requires https://vannevar.atlassian.net/browse/LIB3D-362
            types.checkAllAndThrow(
                ["A", s.AnyOf(s.ArrayOf(s.Number), s.Entity("affineTransform")), a],
                ["B", s.AnyOf(s.ArrayOf(s.Number), s.Entity("affineTransform")), b]
                );
            if(a.primitive) {
                a = a.mat;
            }
            if(b.primitive) {
                b = b.mat;
            }
            return primitive('affineTransform', {mat: multMatrix(a, b)});
        },
        /** Rotation around X axis
         *  @param  {number} phi - rotation angle, in degrees
         *  @return {this}         this, for chaining
         */
        rotateX:function (phi) {
            types.checkAllAndThrow(
                ["XRotation", s.Number, phi]);
            phi = phi * Math.PI / 180;
            var sin = Math.sin(phi), cos = Math.cos(phi);
            return primitive('affineTransform', {mat: [
                 1,    0,    0, 0,
                 0,  cos,  sin, 0,
                 0, -sin,  cos, 0,
                 0,    0,    0, 1
            ]});
        },
        /** Rotation around Y axis
         *  @param  {number} phi - rotation angle, in degrees
         *  @return {this}         this, for chaining
         */
        rotateY: function (phi) {
            types.checkAllAndThrow(
                ["YRotation", s.Number, phi]);
            phi = phi * Math.PI / 180;
            var sin = Math.sin(phi), cos = Math.cos(phi);
            return primitive('affineTransform', {mat: [
                  cos, 0, -sin, 0,
                    0, 1,    0, 0,
                  sin, 0,  cos, 0,
                    0, 0,    0, 1
            ]});
        },
        /** Rotation around Z axis
         *  @param  {number} phi - rotation angle, in degrees
         *  @return {this}         this, for chaining
         */
        rotateZ: function (phi) {
            types.checkAllAndThrow(
                ["ZRotation", s.Number, phi]);
            phi = phi * Math.PI / 180;
            var sin = Math.sin(phi), cos = Math.cos(phi);
            return primitive('affineTransform', {mat: [
                  cos,  sin, 0, 0,
                 -sin,  cos, 0, 0,
                    0,    0, 1, 0,
                    0,    0, 0, 1
            ]});
        },
        /** Reflect against specified plane
         *  @param  {number[]|Point} normal - plane's normal vector
         *  @param  {number[]|Point} origin - in-plane point
         *  @return {object}                - affineTransform entity
         */
        reflect: function (n, p) {
            types.checkAllAndThrow(
                ["Normal", s.AnyOf(s.Entity('vector'), s.Type('position')), n],
                ["Point", s.AnyOf(s.Entity('point'), s.Type('position')), n]);
            n = vecCoords(n);
            p = coords(p);
            var nx = n[0], ny = n[1], nz = n[2],
                px = p[0], py = p[1], pz = p[2];

            var len = Math.sqrt(nx*nx + ny*ny + nz*nz);
            nx /= len; ny /= len; nz /= len;

            var d = -nx * px - ny * py - nz * pz;

            return primitive('affineTransform', {mat: [
                1.0 - 2 * nx * nx,  -2 * nx * ny,       -2 * nx * nz,       -2 * nx * d,
                -2 * nx * ny,       1.0 - 2 * ny * ny,  -2 * ny * nz,       -2 * ny * d,
                -2 * nx * nz,       -2 * ny * nz,       1.0 - 2 * nz * nz,  -2 * nz * d,
                0,                  0,                  0,                  1
            ]});
        },
        /** Rotate around arbitrary vector
         *  @param  {number[]|Vector} axis - rotation axis
         *  @param  {number}          phi  - rotation angle, in degrees
         *  @return {object}                - affineTransform entity
         */
        rotateAboutAxis: function (a, phi) {
            types.checkAllAndThrow(
                ["Axis", s.AnyOf(s.Entity('vector'), s.Type('position')), a],
                ["Rotation", s.Number, phi]);
            phi = phi * Math.PI / 180;
            var sin = Math.sin(phi), cos = Math.cos(phi);
            a = vecCoords(a);
            a = normalize(a);
            var x = a[0], y = a[1], z = a[2];
            return primitive('affineTransform', {mat: [
                cos+x*x*(1-cos),    x*y*(1-cos)-z*sin, y*sin+x*z*(1-cos),  0,
                z*sin+x*y*(1-cos),  cos+y*y*(1-cos),   -x*sin+y*z*(1-cos), 0,
                -y*sin+x*z*(1-cos), x*sin+y*z*(1-cos), cos+z*z*(1-cos),    0,
                0,                  0,                 0,                  1
            ]});
        },
        /** 3D scaling
         *  @param  {number[]|Vector} scale - scaling vector
         *  @return {object}                - affineTransform entity
         */
        scale: function(scale) {
            types.checkAllAndThrow(
                ["Scale", s.AnyOf(s.Entity('vector'), s.Type('position')), scale]);
            scale = vecCoords(scale);
            return primitive('affineTransform', {mat: [
                scale[0],   0,          0,          0,
                   0,       scale[1],   0,          0,
                   0,       0,          scale[2],   0,
                   0,       0,          0,          1
            ]});
        },
        /** 3D translation
         *  @param  {number[]|Vector} scale - displacement vector
         *  @return {object}                - affineTransform entity
         */
        translate: function (d) {
            types.checkAllAndThrow(
                ["Displacement", s.AnyOf(s.Entity('vector'), s.Type('position')), d]);
            d = vecCoords(d);
            return primitive('affineTransform', {mat: [
                 1,  0,  0, d[0],
                 0,  1,  0, d[1],
                 0,  0,  1, d[2],
                 0,  0,  0,  1
            ]});
        }
    },

    /** Constructs infinite plane
     *
     *  @function
     *  @param  {number[]|Point}  origin - in-plane point
     *  @param  {number[]|Vector} normal - plane's normal vector
     *  @return {Plane}
     */
    plane: function (o, n) {
        types.checkAllAndThrow(
            ["Origin", s.AnyOf(s.Type("position"), s.Entity("point")), o],
            ["Normal", s.AnyOf(s.Type("position"), s.Entity("vector")), n]);
        return primitive('plane', {
            origin: coords(o),
            normal: vecCoords(n)
        })
    }
};

// Operations
//******************************************************************************
var ops =
/** Operation constructors
 *  This documentation isn't precise on argument and result types,
 *  because functions listed here effectively create operation objects.
 *  So functions here are documented in terms of types
 *  these operations require as arguments and produce as results.
 *  Due to operation nesting and use of direct string identifiers,
 *  each of these functions can receive {@link string}, {@link Operation}
 *  along with types listed in parameter description.
 *  And each of these functions produces {@link Operation} object.
 *  @namespace operations
 */
{
    /** identity pseudo-operation
     *  Returns its single argument
     *  Used in cases where some entity should be directly mapped to output
     *
     *  @function
     *  @param  {Entity} entry - any entity
     *  @return {Entity}       - entry, unchanged
     */
    identity: function(entry) {
        var r = new Operation('identity');
        r.args = [entry];
        r.toJSON = function () {
            return Operation.prototype.toJSON.call(this)[1];
        };
        return r;
    },
    /** 'list' operation
     *  Accepts arbitrary list of entity/operation arguments
     *  @function
     *  @param  {...Entity} arg - any entity or operation
     *  @return {Entity[]}        list of entities
     */
    list: function() {
        var r = new Operation('list');
        r.args = toArray(arguments);
        return r;
    },
    /** 'repr' operation
     *  Produces Brep object in desired format.
     *  "content" field, which contains actual data, may be zip-packed and base64 encoded
     *  You cannot enable compression and disable base64-coding
     *  Format identifiers supported:
     *  - "x_b":  Parasolid binary format
     *  - "x_t":  Parasolid textual format
     *  - "iges": IGES format
     *  - "step": STEP
     *  - "sat":  SAT
     *  @function
     *  @param  {string}                    format identifier
     *  @param  {Entity}                    entity which should be converted to BREP
     *  @param  {boolean} [is_compressed] - compress content data stream or not, default false
     *  @param  {boolean} [is_base64]     - encode content data stream as base-64 or not, default true
     *  @return {Entity}  BREP
     */
    repr: op('repr', 4),
    /** 'raw' operation
     *  Accepts operation name and variadic list of its arguments directly
     *  Use with caution, only when you know what you do
     *  @function
     *  @param  {string}    name - operation identifier
     *  @param  {...Entity} arg  - any entity or operation
     *  @return {Entity[]}         list of entities
     */
    raw: function() {
        var r = new Operation(arguments[0]);
        r.args = toArray(arguments).slice(1);
        return r;
    },
    /** 'union' operation
     *  Computes union of two geometries
     *  @function
     *  @param  {Sheet|Solid} left
     *  @param  {Sheet|Solid} right
     *  @return {Mesh}        union result
     */
    unite: op('union', 2),
    /** 'intersection' operation
     *  Computes intersection of two geometries
     *  @function
     *  @param  {Sheet|Solid} left
     *  @param  {Sheet|Solid} right
     *  @return {Mesh}        intersection result
     */
    intersect: op('intersection', 2),
    /** 'difference' operation
     *  Subtracts right geometry from the left one
     *  @function
     *  @param  {Sheet|Solid} left  - entity to subtract from
     *  @param  {Sheet|Solid} right - entity being subtracted from left
     *  @return {Mesh}                subtraction result
     */
    subtract: op('difference', 2),
    /** 'evalDist' operation
     *  Computes distance between two geometries
     *  @function
     *  @param  {Point|Wire|Sheet|Solid} left
     *  @param  {Point|Wire|Sheet|Solid} right
     *  @return {number}                 distance between entities
     */
    evalDist: op('evalDist', 2),
    /** 'transform' operation
     *  Transforms 3D entity using affine matrix
     *  @function
     *  @param  {Point|Wire|Sheet|Solid} entity          - entity to transform
     *  @param  {Affine}                 transformation  - 3D affine matrix
     *  @return {Point|Wire|Sheet|Solid}                   first argument, transformed
     */
    transform: op('transform', 2),
    /** 'evalMassProps' operation
     *  Computes mass properties of entity
     *
     *  @function
     *  @param  {Wire|Sheet|Solid} entity
     *  @return {MassProps}        mass properties; not defined in this module because cannot be used as query input
     */
    evalMassProps: op('evalMassProps', 1),
    /** 'trim' operation
     *  Trims surface with a curve
     *  @function
     *  @param  {Sheet} sheet - sheet to be trimmed
     *  @param  {Wire}  curve - closed curve which will trim surface (will be projected onto surface if not resides on it)
     *  @return {Sheet}         trimmed sheet
     */
    trim: op('trim', 2),
    /** 'crossSection' operation
     *  Sections solid or sheet body with surface
     *  The result is a piece of surface which forms section
     *  @function
     *  @param  {Solid|Sheet} body    - solid or sheet body to section
     *  @param  {Plane}       surface - plane or cylinder surface to section with
     *  @return {Sheet}                 resulting cross-section
     */
    crossSection: op('crossSection', 2),
    /** 'extractSheetBoundary' operation
     *  Extracts a sheet body's boundary as a wire body.
     *  @function
     *  @param  {Sheet}       body    - sheet body to extract boundary of
     *  @return {Sheet}                 resulting boundary
    */
     extractSheetBoundary: op('extractSheetBoundary', 1),
    /** 'intersectBodyWithLine' operation
     *  Computes a list of points where line intersects faces of specified body
     *  Points are ordered by their position on the line, along line's main direction
     *  @function
     *  @param  {Sheet|Solid} body - solid or sheet body to intersect
     *  @param  {Wire}        line - intersection line
     *  @return {Point[]}            list of intersection points
     */
    intersectBodyWithLine: op('intersectBodyWithLine', 2),
    /** 'extrude' operation
     *  Extrudes body along direction, until second body is reached
     *  @function
     *  @param  {Point|Wire|Sheet} profile   - extruded profile
     *  @param  {Sheet|Solid}      bound     - bounding body
     *  @param  {Vector}           direction - extrusion direction
     *  @return {Mesh}
     */
    extrude: op('extrude', 3),
    /** 'extrudeWithDistance' operation
     *  Extrudes body along direction for a specified distance
     *  @function
     *  @param  {Point|Wire|Sheet} body      - extruded profile
     *  @param  {number}           distance  - 'height' of extrusion
     *  @param  {Vector}           direction - extrusion direction
     *  @return {Mesh}
     */
    extrudeWithDistance: op('extrudeWithDistance', 3),
    /** 'sweep' operation
     *  Sweeps wire or sheet profile along guide wire
     *  @function
     *  @param  {Wire[]|Sheet[]} profiles - profiles being swept
     *  @param  {Wire[]}         guides   - guide wires to sweep along
     *  @return {Mesh}
     */
    sweep: op('sweep', 2),
    /** 'loft' operation
     *  Lofts a set of profiles along a set of guide wires
     *  @function
     *  @param  {Wire[]|Sheet[]} profiles      - lofted profiles
     *  @param  {Wire[]}         guides        - lofting guides
     *  @param  {Point[]}        startVertices - starting vertices for lofted profiles
     *  @return {Mesh}
     */
    loft: op('loft', 3),
    /** 'revolve' operation
     *  Spins specified profile around axis based at origin for a specified angle
     *  @function
     *  @param  {Point|Wire|Sheet} profile - spinned profile
     *  @param  {Point}            origin  - rotation center
     *  @param  {Vector}           axis    - rotation axis, which is normal vector to rotation plane
     *  @param  {number}           angle   - spinning angle
     *  @return {Mesh}
     */
    revolve: op('revolve', 4),
    /** 'evalCurveLength' operation
     *  Computes curve length
     *  @function
     *  @param  {Curve}  curve
     *  @return {number}
     */
    evalCurveLength: op('evalCurveLength', 1),
    /** 'tessellate' operation
     *  Converts BREP body to a polygonal mesh
     *  @function
     *  @param  {Solid}    body              - body being tessellated
     *  @param  {number}  [linearTolearance] - the minimum linear size of any detail to be visible
     *  @param  {number}  [angularSize]      - the angle, in degrees, which provided body occupies in field of view
     *  @return {Mesh}
     */
    tessellate: function() {
        var r = new Operation('tessellate');
        r.args = [ arguments[0], arguments[1] || DEFAULT_LINEAR_TOLERANCE, arguments[2] || DEFAULT_ANGULAR_SIZE ];
        return r;
    },
    /** 'tessellateStl' operation
     *  Constructs STL representation of specified BREP
     *  @function
     *  @param  {Body}    body      - body being tessellated
     *  @param  {number}  quality   - tesselation quality, ranges 0-4; the bigger, the better
     *  @return {Entity}  BREP
     */
    tessellateStl: op('tessellateStl', 2),
    /** 'tessellateJson' operation
     *  Constructs JSON representation of specified BREP
     *  @function
     *  @param  {Body}    body      - body being tessellated
     *  @param  {number}  quality   - tesselation quality, ranges 0-4; the bigger, the better
     *  @param  {number}  units     - desired units for result given in terms of relative size of 1 meter
     *  @return {Entity}  BREP
     */
    tessellateJson: op('tessellateJson', 3),
    /** 'createPolylineApprox' operation
     *  Converts NURBS curve to polyline
     *  @function
     *  @param  {Curve}     curve
     *  @return {Point[]}
     */
    createPolylineApprox: op('createPolylineApprox', 1),
    /** 'mirror' operation
     *  Produces entity that reflected about given origin and direction
     *  @function
     *  @param  {Point|Wire|Sheet|Solid} body
     *  @param  {Point}                  origin
     *  @param  {Vector}                 direction
     *  @return {Point|Wire|Sheet|Solid}
     */
    mirror: op('mirror', 3),
    /** 'createLinearPattern' operation
     *  Produces linear pattern of entity in the given direction
     *  that is separated by spacing parameter
     *  @function
     *  @param  {Point|Wire|Sheet|Solid}  pattern
     *  @param  {Vector}                  direction
     *  @param  {number}                  spacing   - distance between pattern copies
     *  @param  {number}                  nEntities - repetitions count
     *  @return {Point|Wire|Sheet|Solid}
     */
    createLinearPattern: op('createLinearPattern', 4),
    /** 'createCircularPattern' operation
     *  Produces circular pattern of entity in the given direction
     *  that is separated by angle between each instance
     *  @function
     *  @param  {Point|Wire|Sheet|Solid}  pattern
     *  @param  {Point}                   origin
     *  @param  {Vector}                  direction - direction vector in which to create patterns
     *  @param  {number}                  angle     - angle between instances
     *  @param  {number}                  nEntities - repetitions count
     *  @return {Point|Wire|Sheet|Solid}
     */
    createCircularPattern: op('createCircularPattern', 5),
    /** 'createPlanarSheet' operation
     *  Creates a sheet body from a closed curve
     *  @function
     *  @param  {Wire}  curve - closed curve
     *  @return {Sheet}
     */
    createPlanarSheet: op('createPlanarSheet', 1),
     /** 'sectionBody' operation
     *  Sections a body with a plane or a sheet
     *  @function
     *  @param  {Sheet|Solid} target
     *  @param  {Sheet|Plane} tool
     *  @return {Sheet|Solid} the piece of original body from 'back' tool side (opposite to where tool's normal points)
     */
    sectionBody: op('sectionBody', 2),
    /** 'joinCurves' operation
     *  Joins a closed set of wires to form a solitary wire
     *  @function
     *  @param  {...Wire} wire
     *  @return {Wire}
     */
    joinCurves: op('joinCurves', 1),
    /** 'evalCurve' operation
     *  Evaluates a point and derivatives at a given curve parameter
     *  For b-curves, the parameter space is bound by the lowest and highest value in the knot vector.
     *  For other wires parameter spaces are preset as follows:
     *   - Line      - [0, 1]
     *   - Polyline  - [0, 1]
     *   - Rectangle - [0, 1]
     *   - Arc       - [0, 1]
     *   - Circle    - [0, 2Pi]
     *   - Ellipse   - [0, 2Pi]
     *  Circles and ellipses are always periodic, so it is possible to pass values beyond this interval.
     *  @function
     *  @param  {Curve}   curve
     *  @param  {number}  t       - parameter on curve
     *  @param  {number}  nDerivs - number of derivatives
     *  @return {Point[]}           a point and N derivatives
     */
    evalCurve: op('evalCurve', 3),
    /** 'evalSurface' operation
     *  Evaluates a point and derivatives at a given surface parameter pair
     *  @function
     *  @param  {Sheet}   surface
     *  @param  {number}  u        - surface parameter
     *  @param  {number}  v        - surface parameter
     *  @param  {number}  nUDerivs - derivatives count along U parameter
     *  @param  {number}  nVDerivs - derivatives count along V parameter
     *  @return {Point[]}            result point and its nU*nV-1 derivatives
     */
    evalSurface: op('evalSurface', 5),
    /** 'makeSubCurve' operation
     *  Creates a curve based on an existing curve's parameter interval
     *  For b-curves, the parameter space is bound by the lowest and highest value in the knot vector.
     *  For other wires parameter spaces are preset as follows:
     *   - Line      - [0, 1]
     *   - Polyline  - [0, 1]
     *   - Rectangle - [0, 1]
     *   - Arc       - [0, 1]
     *   - Circle    - [0, 2Pi]
     *   - Ellipse   - [0, 2Pi]
     *  Circles and ellipses are always periodic, so it is possible to pass values beyond this interval.
     *  @function
     *  @param  {Curve}  curve
     *  @param  {number} t0    - subrange start
     *  @param  {number} t1    - subrange end
     *  @return {Curve}          sub-curve from t0 to t1
     */
    makeSubCurve: op('makeSubCurve', 3),
    /** 'makeSubSurface' operation
     *  Creates a sub-surface based on an existing surface's parameter box
     *  @function
     *  @param  {Sheet}  surface
     *  @param  {number} u0 - U subrange start
     *  @param  {number} u1 - U subrange end
     *  @param  {number} v0 - V subrange start
     *  @param  {number} v1 - V subrange end
     *  @return {Sheet}       sub-sheet in ([u0, u1], [v0, v1]) box
     */
    makeSubSurface: op('makeSubSurface', 5),
    /** 'intersectCurves' operation
     *  Finds all intersections between two curves
     *  @function
     *  @param  {Curve}   curve1
     *  @param  {Curve}   curve2
     *  @return {Point[]} intersections list
     */
    intersectCurves: op('intersectCurves', 2),
    /** 'offsetBody' operation
     *  'Bloats' sheet or solid body by offsetting all its faces by specified distance, using faces' normals as directions
     *  @function
     *  @param  {Sheet|Solid} body
     *  @param  {number}      distance
     *  @return {Sheet|Solid}
     */
    offsetBody: op('offsetBody', 2),
    /** 'offsetWire' operation
     *  'Bloats' planar wire body by offsetting its pieces by specified distance
     *  @function
     *  @param  {Wire}   wire     - wire, must lie in one plane
     *  @param  {number} distance - distance to offset
     *  @param  {Vector} normal   - normal to wire's plane
     *  @return {Wire}
     */
    offsetWire: op('offsetWire', 3),
    /** 'createProfiles' operation
     *  Creates a wire or sheet body from a set of wires
     *  @function
     *  @param  {Wire[]}     profiles
     *  @param  {number}     sheetFlag - 0 for wire result, otherwise sheet
     *  @return {Wire|Sheet}             cannot be exported, only usable as input for other operations
     */
    createProfiles: op('createProfiles', 2),
    /** 'compareCurves' operation
     *  Checks if two NURBS curves are equal
     *  Following wires are considered NURBS geometry: lines, polylines, arcs, curves, rectangles.
     *  Returns "1" if wires have equal knots, points and degrees, "0" otherwise.
     *  @function
     *  @param  {Curve}   curve1
     *  @param  {Curve}   curve2
     *  @return {Number}  "1" if equal, "0" otherwise
     */
    compareCurves: op('compareCurves', 2),
    /** 'createResilientProfiles' operation
     *  Creates profiles which inner loops are removed
     *  @function
     *  @param  {Wire[]}  profiles
     *  @return {Sheet}   profile
     */
    createResilientProfiles: op('createResilientProfiles', 1),
    /** 'evalBoundingBox' operation
     *  Calculates axis-aligned bounding box of an array of entities
     *  @function
     *  @param  {Point|Wire|Sheet|Solid[]} entities
     *  @return {Point[]} minimum and maximum points of the bounding box
     */
    evalBoundingBox: op('evalBoundingBox', 1),
    /** 'getBodyInfo' operation
     *  Returns body type and other info of an entity
     *  @function
     *  @param  {Point|Wire|Sheet|Solid} body
     *  @return {BodyInfo} info
     */
    getBodyInfo: op('getBodyInfo', 1)
};

// Helper function
function getCircleCenterByThreePoints(start, middle, end)
{
    // All z-coords are taken to be 0
    // Not valid for real 3d arc

    var offset = Math.pow(middle[0], 2) + Math.pow(middle[1], 2);
    var bc = (Math.pow(start[0], 2) + Math.pow(start[1], 2) - offset) / 2.0;
    var cd = (offset - Math.pow(end[0], 2) - Math.pow(end[1], 2)) / 2.0;
    var det = (start[0] - middle[0]) * (middle[1] - end[1]) - (middle[0] - end[0]) * (start[1] - middle[1]);
    if (Math.abs(det) < eps) {
        throw new FluxModelingError("Cannot get circle center by three points [" +
            start[0] + ", " + start[1] + "], [" + middle[0] + ", " +
            middle[1] + "], [" + end[0] + ", " + end[1] + "]");
    }
    var idet = 1.0/det;

    var centerX =  (bc * (middle[1] - end[1]) - cd * (start[1] - middle[1])) * idet;
    var centerY =  (cd * (start[0] - middle[0]) - bc * (middle[0] - end[0])) * idet;

    return [centerX, centerY, 0.0];
}

function FluxModelingError(message) {
            this.name = 'FluxModelingError';
            this.message = message || 'Invalid or degenerate geometry specified.';
            this.stack = (new Error()).stack;
        }
FluxModelingError.prototype = Object.create(Error.prototype);
FluxModelingError.prototype.constructor = FluxModelingError;

return {
    query:      query,
    utilities:  utilities,
    entities:   entities,
    operations: ops
};

}

/**
    Module exports factory function, which itself constructs module instance
    Factory accepts optional configuration object. If config object is absent,
    it's treated as empty one. If config property is set, its value is used;
    otherwiase, default is used. Please note that "property in object" is used,
    instead of "object.property !== undefined", which allows to distinguish
    config options set to undefined explicitly.

    To disable a related piece of functionality, pass null or undefined in
    the configuration parameters.

    Config options available:
    - registry - UoM registry, used for units conversion; default 'new <index>.measure.Registry()'
    - genId - UUID generator function; default '<index>.uuid.v4'
 */
module.exports = constructModule;
